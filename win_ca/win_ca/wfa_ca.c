/****************************************************************************
 *  (c) Copyright 2009 Wi-Fi Alliance.  All Rights Reserved
 *
 *
 *  LICENSE
 *
 *  License is granted only to Wi-Fi Alliance members and designated
 *  contractors (“Authorized Licensees”).N  Authorized Licensees are granted
 *  the non-exclusive, worldwide, limited right to use, copy, import, export
 *  and distribute this software:
 *  (i) solely for noncommercial applications and solely for testing Wi-Fi
 *  equipment; and
 *  (ii) solely for the purpose of embedding the software into Authorized
 *  Licensee’s proprietary equipment and software products for distribution to
 *  its customers under a license with at least the same restrictions as
 *  contained in this License, including, without limitation, the disclaimer of
 *  warranty and limitation of liability, below.N  The distribution rights
 *  granted in clause
 *  (ii), above, include distribution to third party companies who will
 *  redistribute the Authorized Licensee’s product to their customers with or
 *  without such third party’s private label. Other than expressly granted
 *  herein, this License is not transferable or sublicensable, and it does not
 *  extend to and may not be used with non-Wi-Fi applications.N  Wi-Fi Alliance
 *  reserves all rights not expressly granted herein.N 
 *N 
 *  Except as specifically set forth above, commercial derivative works of
 *  this software or applications that use the Wi-Fi scripts generated by this
 *  software are NOT AUTHORIZED without specific prior written permission from
 *  Wi-Fi Alliance.
 *N 
 *  Non-Commercial derivative works of this software for internal use are
 *  authorized and are limited by the same restrictions; provided, however,
 *  that the Authorized Licensee shall provide Wi-Fi Alliance with a copy of
 *  such derivative works under a perpetual, payment-free license to use,
 *  modify, and distribute such derivative works for purposes of testing Wi-Fi
 *  equipment.
 *N 
 *  Neither the name of the author nor "Wi-Fi Alliance" may be used to endorse
 *  or promote products that are derived from or that use this software without
 *  specific prior written permission from Wi-Fi Alliance.
 *
 *  THIS SOFTWARE IS PROVIDED BY WI-FI ALLIANCE "AS IS" AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR AN PARTICULAR PURPOSE,
 *  ARE DISCLAIMED. IN NO EVENT SHALL WI-FI ALLIANCE BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, THE COST OF PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 *  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE) ARISING IN ANY WAY OUT OF
 *  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ******************************************************************************
 */
/*
 *   Revision History: WINv03.00.00 - Simga 3.0 Release, supports TGn Program including WMM and WPA2
 */

#include <stdio.h>      /* for printf() and fprintf() */
#include <stdlib.h>     /* for atoi() and exit() */
#include <string.h>     /* for memset() */

#ifndef _WINDOWS
#include <arpa/inet.h>  /* for sockaddr_in and inet_addr() */
#include <sys/socket.h> /* for socket(), connect(), send(), and recv() */
#include <sys/select.h>
#include <unistd.h>     /* for close() */
#else
#include <windows.h>
#include <winbase.h>
#include <winsock.h>
#include <stdio.h>
#include <io.h>

#endif

#include "wfa_debug.h"
#include "wfa_main.h"
#include "wfa_types.h"
#include "wfa_tlv.h"
#include "wfa_tg.h"
#include "wfa_cmds.h"
#include "wfa_miscs.h"
#include "wfa_sock.h"
#include "wfa_ca.h"
#include "wfa_agtctrl.h"

#define WFA_ENV_AGENT_IPADDR "WFA_ENV_AGENT_IPADDR"

extern int xcCmdProcGetVersion(unsigned char *parms);
extern dutCommandRespFuncPtr wfaCmdRespProcFuncTbl[];
extern typeNameStr_t nameStr[];
extern char gRespStr[];

int gSock = -1, tmsockfd, gCaSockfd = -1, xcSockfd, btSockfd;
int gtgSend, gtgRecv, gtgTransac;
char gnetIf[32] = "any";
tgStream_t    *theStreams;
long          itimeout = 0;

unsigned short wfa_defined_debug = WFA_DEBUG_ERR | WFA_DEBUG_WARNING | WFA_DEBUG_INFO;
unsigned short dfd_lvl = WFA_DEBUG_DEFAULT | WFA_DEBUG_ERR | WFA_DEBUG_INFO;

/*
 * the output format can be redefined for file output.
 */

int main(int argc, char *argv[])
{
    int nfds;
    struct sockaddr_in servAddr;
    unsigned short servPort, myport; 
    char *servIP=NULL, *tstr=NULL;
    int bytesRcvd;                   
    fd_set sockSet;
    char cmdName[WFA_BUFF_32];
    int i, isFound = 0, nbytes, tag, ret_status, slen,dut_con_error=0;
    int tmsockfd, cmdLen = WFA_BUFF_1K;
    int maxfdn1;
    BYTE xcCmdBuf[WFA_BUFF_1K];
    BYTE caCmdBuf[WFA_BUFF_1K];
    BYTE pcmdBuf[WFA_BUFF_1K];
    char *pcmdStr;
    char respStr[WFA_BUFF_512];

	//start of Windows CLI handling variables
	char wfaCliBuff[128];
	FILE *wfaCliFd;
	char * cliCmd,*tempCmdBuff;
	// end

    printf("%c[%d;%d;%dm", 0x1B, 1,32,40);
    if(argc < 3)
    {
        DPRINT_ERR(WFA_ERR, "Usage: %s <control interface> <local control agent port> [<DUT IP> <DUT PORT> [<Logfile Path>]]\n", argv[0]);
        exit(1);
    }

    myport = atoi(argv[2]); 

    //strcpy(gnetIf, argv[1]);
    if(argc > 3)
    {
    	if(argc < 5)
	    {
            DPRINT_ERR(WFA_ERR, "Usage: %s <control interface> <local control agent port> <DUT IP ADDRESS> <DUT PORT>\n", argv[0]);
        	exit(1);
	    }
        servIP = argv[3];
        if(isIpV4Addr(argv[3])== FALSE)
            return FALSE;
        if(isNumber(argv[4])== FALSE)
           return FALSE;
        servPort = atoi(argv[4]);
	if(argc > 5)
	{
		FILE *logfile;
		int fd;
		logfile = fopen(argv[5],"a");
		if(logfile != NULL)
		{
			fd = _fileno(logfile);
			DPRINT_INFO(WFA_OUT,"redirecting the output to %s\n",argv[5]);
			dup2(fd,1);
			dup2(fd,2);
		}
		else
		{
            		DPRINT_ERR(WFA_ERR, "Cant open the log file continuing without redirecting\n");
		}
	}
    }
    else
    {
    	if((tstr = getenv("WFA_ENV_AGENT_IPADDR")) == NULL)
        {
       	    DPRINT_ERR(WFA_ERR, "Environment variable WFA_ENV_AGENT_IPADDR not set or specify DUT IP/PORT\n");
       		exit(1);
        }
        if(isIpV4Addr(tstr)== FALSE)
            return FALSE;
    	servIP= tstr; 
        if((tstr = getenv("WFA_ENV_AGENT_PORT")) == NULL)
        {
           DPRINT_ERR(WFA_ERR, "Environment variable WFA_ENV_AGENT_PORT not set or specify DUT IP/PORT\n");
           exit(1);
        }
        if(isNumber(tstr)== FALSE)
           return FALSE;
    	servPort = atoi(tstr); 
    }

#if 0
    /* raise itself priority class first */
    SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);
#endif

    tmsockfd = wfaCreateTCPServSock(myport);

    maxfdn1 = tmsockfd + 1;

    FD_ZERO(&sockSet);
    if(gSock == -1)
    {
        if ((gSock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
        {
            DPRINT_ERR(WFA_ERR, "socket() failed: %i", errno);
            exit(1);
        }

        memset(&servAddr, 0, sizeof(servAddr)); 
        servAddr.sin_family      = AF_INET;
        servAddr.sin_addr.s_addr = inet_addr(servIP);
        servAddr.sin_port        = htons(servPort);
        if (connect(gSock, (struct sockaddr *) &servAddr, sizeof(servAddr)) < 0)
        {
            DPRINT_ERR(WFA_ERR, "connect() failed: %i, continuing\n", errno);
            dut_con_error = 1;
            //exit(1);
        }
	else
            DPRINT_INFO(WFA_OUT, "Connected to the DUT/TGEN %s:%d\n",servIP,servPort);


    }
    for(;;)
    {
    	fflush(stdout);
        FD_ZERO(&sockSet);
        FD_SET(tmsockfd, &sockSet);
        maxfdn1 = tmsockfd + 1;

        if(gCaSockfd != -1)
        {
            FD_SET(gCaSockfd, &sockSet);
            if(maxfdn1 < gCaSockfd)
                maxfdn1 = gCaSockfd +1; 
        }

        if(gSock == -1)
        {
            if ((gSock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
            {
                DPRINT_ERR(WFA_ERR, "socket() failed: %i", errno);
                exit(1);
            }

            memset(&servAddr, 0, sizeof(servAddr)); 
            servAddr.sin_family      = AF_INET;
            servAddr.sin_addr.s_addr = inet_addr(servIP);
            servAddr.sin_port        = htons(servPort);

            if (connect(gSock, (struct sockaddr *) &servAddr, sizeof(servAddr)) < 0)
            {
                DPRINT_ERR(WFA_ERR, "connect() failed: %i,continuing\n", errno);
                dut_con_error = 1;
            }
            else
	    {
	           dut_con_error = 0;
                   DPRINT_INFO(WFA_OUT, "Connected to the DUT/TGEN %s:%d\n",servIP,servPort);
            }
        }
	    else
	    {
			if(dut_con_error)
			{
                DPRINT_INFO(WFA_OUT, "Trying to Connect to %s:%d ...\n",servIP,servPort);
	            if (connect(gSock, (struct sockaddr *) &servAddr, sizeof(servAddr)) < 0)
                {
                    DPRINT_ERR(WFA_ERR, "connect() failed: %i,continuing\n", errno);
                }
				else
				{
				    dut_con_error = 0;
                    DPRINT_INFO(WFA_OUT, "Connected to the DUT/TGEN %s:%d\n",servIP,servPort);
				}
			}
			else
            {
                FD_SET(gSock, &sockSet);
                if(maxfdn1 < gSock)
                    maxfdn1 = gSock +1; 
            }
	    }

        if((nfds = select(maxfdn1, &sockSet, NULL, NULL, NULL)) < 0)
        {
            if(errno == EINTR)
                continue;
            else
                DPRINT_WARNING(WFA_WNG, "select error %i", errno);
        }
 
        DPRINT_INFO(WFA_OUT, "new event \n");
        if(FD_ISSET(tmsockfd, &sockSet))
        {
            gCaSockfd = wfaAcceptTCPConn(tmsockfd);
            DPRINT_INFO(WFA_OUT, "accept new connection\n");
            continue;
        }
   
        if(gCaSockfd > 0 && FD_ISSET(gCaSockfd, &sockSet))
        {
            memset(xcCmdBuf, '\0', WFA_BUFF_1K);
            memset(gRespStr, '\0', WFA_BUFF_512);

            nbytes = wfaCtrlRecv(gCaSockfd, xcCmdBuf); 
            DPRINT_INFO(WFA_OUT, "message %s %i\n", xcCmdBuf, nbytes);
            if(nbytes <=0)
            {
#ifndef _WINDOWS
                shutdown(gCaSockfd, SHUT_WR);
                close(gCaSockfd);
#else
				closesocket(gCaSockfd);
#endif
                gCaSockfd = -1;
                continue;
            }
    
            /*
             * send back to command line or TM.
             */
            //sleep(1); /* having this is for slowing down unexpected output result on CLI command sometimes */
            memset(respStr, '\0', WFA_BUFF_128);
			if(dut_con_error) //Retry Once more for the DUT to come up
			{
				if(gSock != -1)
				{
                    if (connect(gSock, (struct sockaddr *) &servAddr, sizeof(servAddr)) < 0)
                    {
                        DPRINT_ERR(WFA_ERR, "connect() failed: %i", errno);
                    }
                    else
					{
	                   dut_con_error = 0;
                       DPRINT_INFO(WFA_OUT, "Connected to the DUT/TGEN %s:%d\n",servIP,servPort);
					}
				}
			}
			if(dut_con_error)
			{
                sprintf(respStr, "status,RUNNING\r\n");
                wfaCtrlSend(gCaSockfd, (BYTE *)respStr, strlen(respStr));
                sprintf(respStr, "status,ERROR,DUT_%s:%d_NOT_READY\r\n",servIP,servPort);
                wfaCtrlSend(gCaSockfd, (BYTE *)respStr, strlen(respStr));
			}
			else
			{
                sprintf(respStr, "status,RUNNING\r\n");
                wfaCtrlSend(gCaSockfd, (BYTE *)respStr, strlen(respStr));

                DPRINT_INFO(WFA_OUT, "%s\n", respStr);
                slen = (int )strlen((char *)xcCmdBuf);

                DPRINT_INFO(WFA_OUT, "last %x last-1  %x last-2 %x last-3 %x\n", cmdName[slen], cmdName[slen-1], cmdName[slen-2], cmdName[slen-3]);

                xcCmdBuf[slen-3] = '\0';


                isFound = 0;
    

#ifdef _WINDOWS

				tempCmdBuff=(char* )malloc(sizeof(xcCmdBuf));
				memcpy(tempCmdBuff,xcCmdBuf,sizeof(xcCmdBuf));
			
				memcpy(cmdName, strtok_r((char *)tempCmdBuff, ",", (char **)&pcmdStr), 32);
				printf("\nInside the new block \n");

				wfaCliFd=fopen("c:\\WFA\\WfaEndpoint\\wfa_cli.txt","r");
				printf("\nAfter File open \n");
//				fgets(wfaCliBuff, 64, wfaCliFd);
//				printf("Line read from CLI file : %s",wfaCliBuff);


//				if(wfaCliFd!= NULL && !ferror(wfaCliFd))
				if(wfaCliFd!= NULL)
				{
					//printf("\nInside File open \n");
					while(fgets(wfaCliBuff, 128, wfaCliFd) != NULL)
					{
						//printf("Line read from CLI file : %s",wfaCliBuff);
						if(ferror(wfaCliFd))
							break;
						cliCmd=strtok(wfaCliBuff,"-");
						if(strcmp(cliCmd,cmdName) == 0)
						{
							strcpy(cmdName,"wfa_cli_cmd");
							pcmdStr = &xcCmdBuf[0];
							break;
						}
					}
					fclose(wfaCliFd);

				}
				printf("\nOutside the new block \n");
				free(tempCmdBuff);
				if(strcmp(cmdName,"wfa_cli_cmd") != 0)
					memcpy(cmdName, strtok_r((char *)xcCmdBuf, ",", (char **)&pcmdStr), 32);


#else
			memcpy(cmdName, strtok_r((char *)xcCmdBuf, ",", (char **)&pcmdStr), 32);

#endif


                i = 0;
                while(nameStr[i].type != -1)
                {
                    if(strcmp(nameStr[i].name, cmdName) == 0)
                    {
                        isFound = 1;
                        break;
                    }
                    i++;
                }

                DPRINT_INFO(WFA_OUT, "%s\n", cmdName);

                if(isFound == 0)
                {
#ifndef _WINDOWS
                    sleep(1);						
#else
					Sleep(1);
#endif
                    sprintf(respStr, "status,INVALID\r\n");
                    wfaCtrlSend(gCaSockfd, (BYTE *)respStr, strlen(respStr));
                    DPRINT_WARNING(WFA_WNG, "Command not valid, check the name\n");
                    continue;
                }

                memset(pcmdBuf, '\0', WFA_BUFF_1K); 
                if(nameStr[i].cmdProcFunc(pcmdStr, pcmdBuf, &cmdLen)==FALSE)
                {
#ifndef _WINDOWS
                    sleep(1);
#else
					Sleep(1);
#endif
                    sprintf(respStr, "status,INVALID\r\n");
                    wfaCtrlSend(gCaSockfd, (BYTE *)respStr, strlen(respStr));
                    DPRINT_WARNING(WFA_WNG, "Incorrect command syntax\n");
                    continue;
                }

                /*
                 * send to DUT.
                 */
                if(send(gSock, pcmdBuf, cmdLen, 0) != cmdLen)
                {
                    DPRINT_WARNING(WFA_WNG, "Incorrect sending ...\n");
                    continue;
                }

                DPRINT_INFO(WFA_OUT, "sent to DUT\n");
                //sleep(1);
            } /* done with gCaSockfd */
		}
        if(gSock > 0 && FD_ISSET(gSock, &sockSet))
        {
            DPRINT_INFO(WFA_OUT, "received from DUT\n");
#ifndef _WINDOWS
            sleep(1);
#else
			Sleep(1);
#endif
            memset(respStr, 0, WFA_BUFF_128);
            memset(caCmdBuf, 0, WFA_BUFF_1K);
            if ((bytesRcvd = recv(gSock, caCmdBuf, WFA_BUFF_1K, 0)) <= 0)
            {
                DPRINT_WARNING(WFA_WNG, "recv() failed or connection closed prematurely\n");
        	    FD_CLR(gSock, &sockSet);
#ifndef _WINDOWS
		        close(gSock);
#else
				closesocket(gSock);
#endif
		        gSock=-1;
                continue;
            }

#if DEBUG 
            for(i = 0; i< bytesRcvd; i++)
               printf("%x ", caCmdBuf[i]);
               printf("\n");
#endif
            tag = ((wfaTLV *)caCmdBuf)->tag;     
          
            memcpy(&ret_status, caCmdBuf+4, 4);
            DPRINT_INFO(WFA_OUT, "bytes=%i, %i,%i,%x %x %x %x \n", bytesRcvd, ((wfaTLV *)caCmdBuf)->tag,((wfaTLV *)caCmdBuf)->len, *(caCmdBuf+4), *(caCmdBuf+5), *(caCmdBuf+6), *(caCmdBuf+7));

            DPRINT_INFO(WFA_OUT, "tag %i \n", tag-WFA_STA_COMMANDS_END);
			// for downward compatibility 
			// if the TAG is new in tag pool
			if((tag != 0 && tag > WFA_STA_NEW_CMD_RESPONSE_START && tag < WFA_STA_NEW_CMD_RESPONSE_END) && wfaCmdRespProcFuncTbl[tag-WFA_STA_NEW_CMD_RESPONSE_START + (WFA_STA_RESPONSE_END - WFA_STA_COMMANDS_END - 1)] != NULL)
			{
				wfaCmdRespProcFuncTbl[tag-WFA_STA_NEW_CMD_RESPONSE_START + (WFA_STA_RESPONSE_END - WFA_STA_COMMANDS_END - 1)](caCmdBuf);
			}
			else if((tag != 0 && tag < WFA_STA_RESPONSE_END) && wfaCmdRespProcFuncTbl[tag-WFA_STA_COMMANDS_END] != NULL)
            {
                wfaCmdRespProcFuncTbl[tag-WFA_STA_COMMANDS_END](caCmdBuf);
            }
            else
                DPRINT_WARNING(WFA_WNG, "function not defined\n");
        } /* if(gCaSock */

    } /* for */

#ifndef _WINDOWS
    close(gSock);
#else
	closesocket(gSock);
#endif
    exit(0);
}