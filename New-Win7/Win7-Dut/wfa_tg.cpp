
/****************************************************************************
 *  (c) Copyright 2007 Wi-Fi Alliance.  All Rights Reserved
 *
 *  LICENSE
 *
 *  License is granted only to Wi-Fi Alliance members and designated
 *  contractors (“Authorized Licensees”).N  Authorized Licensees are granted
 *  the non-exclusive, worldwide, limited right to use, copy, import, export
 *  and distribute this software:
 *  (i) solely for noncommercial applications and solely for testing Wi-Fi
 *  equipment; and
 *  (ii) solely for the purpose of embedding the software into Authorized
 *  Licensee’s proprietary equipment and software products for distribution to
 *  its customers under a license with at least the same restrictions as
 *  contained in this License, including, without limitation, the disclaimer of
 *  warranty and limitation of liability, below.N  The distribution rights
 *  granted in clause
 *  (ii), above, include distribution to third party companies who will
 *  redistribute the Authorized Licensee’s product to their customers with or
 *  without such third party’s private label. Other than expressly granted
 *  herein, this License is not transferable or sublicensable, and it does not
 *  extend to and may not be used with non-Wi-Fi applications.N  Wi-Fi Alliance
 *  reserves all rights not expressly granted herein.N 
 *N 
 *  Except as specifically set forth above, commercial derivative works of
 *  this software or applications that use the Wi-Fi scripts generated by this
 *  software are NOT AUTHORIZED without specific prior written permission from
 *  Wi-Fi Alliance.
 *N 
 *  Non-Commercial derivative works of this software for internal use are
 *  authorized and are limited by the same restrictions; provided, however,
 *  that the Authorized Licensee shall provide Wi-Fi Alliance with a copy of
 *  such derivative works under a perpetual, payment-free license to use,
 *  modify, and distribute such derivative works for purposes of testing Wi-Fi
 *  equipment.
 *N 
 *  Neither the name of the author nor "Wi-Fi Alliance" may be used to endorse
 *  or promote products that are derived from or that use this software without
 *  specific prior written permission from Wi-Fi Alliance.
 *
 *  THIS SOFTWARE IS PROVIDED BY WI-FI ALLIANCE "AS IS" AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR AN PARTICULAR PURPOSE,
 *  ARE DISCLAIMED. IN NO EVENT SHALL WI-FI ALLIANCE BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, THE COST OF PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 *  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE) ARISING IN ANY WAY OUT OF
 *  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ******************************************************************************
 */
/*
 *    File: wfa_tg.c 
 *    Library functions for traffic generator.
 *    They are shared with both TC and DUT agent.
 * 
 *    Revision History:
 *       2008/11/12 --  Sigma Beta2 - Timer Fixed for START SYNC and TRANS profile for Windows code - [AV]
 *       2009/09/30 -- WINv03.00.00 - Simga 3.0 Release, supports TGn Program including WMM and WPA2 [QH]
 */
#include "stdafx.h"
#include <stdio.h>
#ifdef _WINDOWS
//#include <winsock.h>
#include "winsock2.h"
#include <windows.h>
#include <time.h>
#include <random>
#include <iostream>
#include <cstdlib>

#else
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <signal.h>
#include <sys/time.h>
#include <netdb.h>
#include <pthread.h>
#endif
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <math.h>

#include "wfa_debug.h"
#include "wfa_ver.h"
#include "wfa_main.h"
#include "wfa_tlv.h"
#include "wfa_tg.h"
#include "wfa_cmds.h"
#include "wfa_sock.h"
#include "wfa_rsp.h"
#include "wfa_wmmps.h"
#include "wfa_miscs.h"
#include "wfa_types.h"
#ifdef _WINDOWS
#define CLOSE closesocket
#else
#define CLOSE close
#endif
//extern tgStream_t *gStreams;
extern tgStream_t gStreams[WFA_MAX_TRAFFIC_STREAMS];
extern BOOL gtgRecv;
extern BOOL gtgSend;
extern BOOL gtgTransac;
extern int btSockfd;
extern int txSockfd;
extern int gtimeOut;
extern int gRegSec;
extern char gCmdStr[WFA_CMD_STR_SZ];

extern int hasRecv;

extern int adj_latency;

extern tgStream_t *findStreamProfile(int);
extern DWORD WINAPI wfa_traffic_resend_results_thread(void *direction);
extern int wfaTrafficSendTo(int, char *, int, struct sockaddr *);
extern int wfaTrafficRecv(int, char *, struct sockaddr *);
extern unsigned short wfa_defined_debug;
extern int tgSockfds[];
#define DONE 1
#ifdef WFA_WMM_EXT
extern tgWMM_t wmm_thr[];

extern double min_rttime;
extern double gtgPktRTDelay;
extern BOOL gtgStartSync;
extern tgE2EStats_t *e2eStats;
extern int e2eCnt;
extern int gettimeofday(struct timeval *tv, void *tz);
extern void int2BuffBigEndian(int val, char *buf);
extern int bigEndianBuff2Int(char *buff);

#ifdef WFA_WMM_PS_EXT
extern int gtgWmmPS;
extern wfaWmmPS_t wmmps_info;
extern int psSockfd;
extern unsigned int psTxMsg[];
extern unsigned int psRxMsg[];
extern int gtgPsPktRecvd;

extern void wfaSetDUTPwrMgmt(int mode);
void wmmps_wait_state_proc();

#endif

#endif

static int runLoop = 0;
static int streamId = 0;
int totalTranPkts = 0, sentTranPkts = 0;
static int slotCnt = 0;

extern int mainSendThread;

//#ifdef WFA_VHT5G_EXT
static int becnt = 0;
//#endif

#ifdef WFA_WMM_EXT
static int usedThread = 0;
#ifndef _WINDOWS

char e2eResults[24];
#else
char e2eResults[124];
#endif
#if 0  /* for test purpose only */
char *e2eResults = "/tmp/e2e1198798626.txt";
#endif

#endif

extern dutCmdResponse_t gGenericResp;


extern tgStream_t *theStreams;

#ifdef _WINDOWS
extern DWORD WINAPI wfa_wpa2_sleep_thread(void *thr_param);
extern int vend;
int timer_dur=0;
DWORD thr_id;
extern  DWORD recvThr;
#endif
 
tgStream_t *findStreamProfile(int id);
/* Some devices may only support UDP ECHO and do not have ICMP level ping */
// #define WFA_PING_UDP_ECHO_ONLY     1

/* this is to stop sending packets by timer       */ 
void tmout_stop_send(int num)
{
   struct timeval af;
#ifdef WFA_WMM_EXT
   int i =0;
#endif
   gettimeofday(&af,0);
   DPRINT_INFOL(WFA_OUT, "Exiting sendLongFile  at sec %d usec %d\n", af.tv_sec,af.tv_usec);
   DPRINT_INFOL(WFA_OUT, "Timer fired, stop sending traffic\n");

   /*
    *  After runLoop reset, all sendLong will stop
    */
   runLoop = 0;

#ifdef WFA_WMM_EXT
   /*
    * once usedThread is reset, WMM tests using multithread is ended
    * the threads will be reused for the next test.
    */
   usedThread = 0;
#endif

   /*
    * once the stream table slot count is reset, it implies that the test
    * is done. When the next set profile command comes in, it will reset/clean
    * the stream table. 
    */
   slotCnt = 0;

   /*
    * The test is for DT3 transaction test.
    * Timeout to stop it.
    */
   if(gtgTransac != 0)
   {
      gtgSend = 0;
      gtgRecv = 0;
      CLOSE(btSockfd);
      btSockfd = -1;

#ifdef WFA_WMM_EXT
      /* Voice End 2 End Sync */
      min_rttime = 0xFFFFFFFF;
      if(gtgStartSync != 0)
      {
         gtgStartSync = 0;
         DPRINT_INFOL(WFA_OUT, "stopping StartSync\n");
      }
#endif
   }

#ifdef WFA_WMM_EXT
   /*
    * all WMM streams also stop
    */   
   for(i=0; i<WFA_THREADS_NUM; i++)
   {
      wmm_thr[i].thr_flag = 0;   
   }
#endif
#ifdef resolve
    /* all alarms need to reset */
   alarm(0);
#endif
}

/*
 * findStreamProfile(): search existing stream profile by stream id
 * input: id - stream id;
 * return: matched stream profile
 */

tgStream_t *findStreamProfile(int id)
{
    volatile int i;
    tgStream_t *myStream = gStreams;

    for(i = 0; i< WFA_MAX_WMM_STREAMS; i++)
    {
       if(myStream->id == id)
          return myStream;
       
       myStream++;
    }

    return NULL;
}

/*
 * wfaTGSendPing(): Instruct Traffic Generator to send ping packets
 *
 */
int wfaTGSendPing(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    int totalpkts;
    char cmdStr[128];
    int streamid = ++streamId;
    int interval;      /* it in milli second */ 
    tgPingStart_t *staPing = (tgPingStart_t *)caCmdBuf;
    dutCmdResponse_t *spresp = &gGenericResp;

#ifdef WFA_PING_UDP_ECHO_ONLY
    tgStream_t *myStream = NULL;
#endif

    DPRINT_INFOL(WFA_OUT, "VHT: Entering ...\n");
    if(staPing->frameSize == 0)
       staPing->frameSize = 100;

    if(staPing->frameRate == 0)
       staPing->frameRate = 1;

    interval = (int)((1/staPing->frameRate)*1000);

    if(staPing->duration == 0)
       staPing->duration = 10;

    switch(staPing->type)
    {
        case WFA_PING_ICMP_ECHO:
#ifndef WFA_PING_UDP_ECHO_ONLY
        totalpkts = (int) (staPing->duration * staPing->frameRate);

#if !defined(_CYGWIN) && !defined(_WINDOWS)
        sprintf(cmdStr, "echo streamid=%i > /tmp/spout.txt; /bin/ping %s -i %f -c %i -s %i -q >> /tmp/spout.txt 2>/dev/null&",
          streamid, staPing->dipaddr, interval, totalpkts, staPing->frameSize); 
#else
#ifdef _CYGWIN
        sprintf(cmdStr, "echo streamid=%i > /tmp/spout.txt; /bin/ping %s  %d   %d >> /tmp/spout.txt 2>/dev/null&",
          streamid, staPing->dipaddr,  staPing->frameSize,totalpkts); 
#else
        sprintf(cmdStr, "del /F c:\\WFA\\spout.txt");
        system(cmdStr);

//        interval = 1000;
//        totalpkts = 10;
        sprintf(cmdStr, "start \"MPING\" cmd /C \"myping %s  -l %d -i %d -n %d -f  c:\\WFA\\spout.txt\"",
        staPing->dipaddr,  staPing->frameSize,interval,totalpkts);
        printf("RUN: %s\n", cmdStr);
//        sprintf(cmdStr, "start \"MPING\" cmd /C \"myping %s  -l %d -i 1000 -n 10 -f  c:\\WFA\\spout.txt\"",
//        staPing->dipaddr,  staPing->frameSize);
#endif
#endif
        DPRINT_INFO(WFA_OUT, "Executing %s\n",cmdStr);
        system(cmdStr);

        spresp->status = STATUS_COMPLETE;
        spresp->streamId = streamid;
#elif
        DPRINT_INFO(WFA_OUT, "Only support UDP ECHO\n");
#endif
        break;

        case WFA_PING_UDP_ECHO:
        {
#ifdef WFA_PING_UDP_ECHO_ONLY
        /*
         * Make this like a transaction testing
         * Then make it a profile and run it    
         */
        myStream = &gStreams[slotCnt++];
        memset(myStream, 0, sizeof(tgStream_t));
        memcpy(&myStream->profile, caCmdBuf, len);
        myStream->id = streamid; /* the id start from 1 */ 
        myStream->tblidx = slotCnt-1; 

        btSockfd = wfaCreateUDPSock("127.0.0.1", WFA_UDP_ECHO_PORT);
        if((btSockfd = wfaConnectUDPPeer(btSockfd, staPing->dipaddr, WFA_UDP_ECHO_PORT)) > 0)
        {
            gtgTransac = streamid;        
            gtgSend = streamid;
            totalTranPkts = 512;
            sentTranPkts = 0;

            /*
             * the framerate here is used to derive the timeout 
             * value for waiting transaction echo responses.
             */
            gtimeOut = MINISECONDS/staPing->frameRate;  /* in msec */

            /* set to longest time */
            if(staPing->duration == 0)
                staPing->duration = 3600;
        }
#else
        DPRINT_INFO(WFA_WNG, "Doesn't support UDP Echo\n");
#endif
        break;
        }
        default:
        {
        spresp->status = STATUS_INVALID;
        spresp->streamId = streamid;
        }
    }
        
    wfaEncodeTLV(WFA_TRAFFIC_SEND_PING_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)spresp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

    return WFA_SUCCESS;
}

/*
 * tgStopPing(): Instruct Traffic Generator to stop ping packets
 *
 */
int wfaTGStopPing(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    int streamid = (int )*(caCmdBuf+4); 
    dutCmdResponse_t *stpResp = &gGenericResp;
    char strout[256];
    char _strout[256];
    FILE *tmpfile = NULL;

    DPRINT_INFOL(WFA_OUT, "Entering StopPing ...");

    stpResp->status = STATUS_COMPLETE;
    DPRINT_INFOL(WFA_OUT, "It is WINDOWS\n");
    char *str;
    DPRINT_INFOL(WFA_OUT, "Entering ...\n");

    system("taskkill /IM myping.exe /F");
    tmpfile = fopen("c:\\WFA\\spout.txt", "r+");

    if(tmpfile!=NULL)
    {
       while (fgets(_strout, 100, tmpfile) != NULL ) 
	      {
          DPRINT_INFOL(WFA_OUT, "string in sprout %s\n", _strout);
          strcpy(strout,_strout);

          while((str = strtok(strout, " ")) == NULL)
                   ;
          DPRINT_INFOL(WFA_OUT, "got word 1: %s\n", str);
               
          if(strcmp(str,"sent") == 0)
          {
              str = strtok(NULL, " ");
              DPRINT_INFOL(WFA_OUT, "got word 2: %s\n", str);

              if(str)
                 stpResp->cmdru.pingStp.sendCnt = atoi(str);
              else
                 stpResp->cmdru.pingStp.sendCnt = 0;
          }

          DPRINT_INFOL(WFA_OUT, "sent %i ", stpResp->cmdru.pingStp.sendCnt);

          str = strtok(NULL, " ");
          DPRINT_INFOL(WFA_OUT, "got word 3: %s\n", str);
          if(strcmp(str,"recieved") == 0)
          {
             str = strtok(NULL, " ");
             if(str)
                stpResp->cmdru.pingStp.repliedCnt = atoi(str);
             else
                stpResp->cmdru.pingStp.repliedCnt = 0;   
          }
          DPRINT_INFOL(WFA_OUT, "received %i\n", stpResp->cmdru.pingStp.repliedCnt);
      }
   }
   else
   {
      DPRINT_INFOL(WFA_OUT, "File is empty\n");
   }

   if(tmpfile == NULL)
   {
      DPRINT_ERR(WFA_ERR, "\ninside tmpfile NULL ...\n");
      stpResp->status = STATUS_COMPLETE;

      wfaEncodeTLV(WFA_TRAFFIC_STOP_PING_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)stpResp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

      return WFA_FAILURE;
   }
   else
   {
      DPRINT_INFOL(WFA_OUT, "Sending result back\n");
      fclose(tmpfile);
      wfaEncodeTLV(WFA_TRAFFIC_STOP_PING_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)stpResp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
   }

   return WFA_SUCCESS;
}

void rand_gen_sid()
{
    std::random_device rd;
    std::srand(rd());
    streamId =  std::rand() % 1000;
}
/*
 * wfaTGConfig: store the traffic profile setting that will be used to
 *           instruct traffic generation.
 * input: cmd -- not used
 * response: send success back to controller
 * return: success or fail
 * Note: the profile storage is a global space.
 */
int wfaTGConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    int ret = WFA_SUCCESS;
    tgStream_t *myStream = NULL;
    dutCmdResponse_t *confResp = &gGenericResp;
    
    /* if the stream table over maximum, reset it */ 
    if(slotCnt == WFA_MAX_TRAFFIC_STREAMS)
       slotCnt = 0;

    if(slotCnt == 0)
    {
       DPRINT_INFO(WFA_OUT, "resetting stream table for %d\n",gStreams);
       memset(gStreams, 0, WFA_MAX_TRAFFIC_STREAMS*sizeof(tgStream_t));
    }
   
    DPRINT_INFOL(WFA_OUT, "Entering ...\n");
    myStream = &gStreams[slotCnt++];
    memset(myStream, 0, sizeof(tgStream_t));
    memcpy(&myStream->profile, caCmdBuf, len);
    myStream->id = ++streamId; /* the id start from 1 */ 
    myStream->tblidx = slotCnt-1;

#if 1
    DPRINT_INFO(WFA_OUT, "profile %i direction %i dest ip %s dport %i source %s sport %i rate %i duration %i size %i class %i delay %i hti %i\n", myStream->profile.profile, myStream->profile.direction, myStream->profile.dipaddr, myStream->profile.dport, myStream->profile.sipaddr, myStream->profile.sport, myStream->profile.rate, myStream->profile.duration, myStream->profile.pksize, myStream->profile.trafficClass, myStream->profile.startdelay,myStream->profile.hti);
#endif
 
    confResp->status = STATUS_COMPLETE; 
    confResp->streamId = myStream->id;
    wfaEncodeTLV(WFA_TRAFFIC_AGENT_CONFIG_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)confResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t); 

    return ret;
}

HANDLE recv_mutex;
/*
 * wfaTGRecvStart: instruct traffic generator to start receiving 
 *                 based on a profile
 * input:      cmd -- not used
 * response:   inform controller for "running"
 * return:     success or failed 
 */
int wfaTGRecvStart(int len, BYTE *parms, int *respLen, BYTE *respBuf)
{
    int status = STATUS_COMPLETE, i;
    int numStreams = len/4;
    int streamid, so;
    tgProfile_t *theProfile;
    tgStream_t *myStream;
    int thisSockfd = -1;
#ifdef _WINDOWS
    int iOptVal;
    int iOptLen = sizeof(int);
#endif


    DPRINT_INFO(WFA_OUT, "Entering ...\n");

    /*
     * The function wfaSetProcPriority called here is to enhance the real-time
     * performance for packet receiving. It is only for tuning and optional
     * to implement
     */
    //wfaSetProcPriority(60);

    for(i=0; i<numStreams; i++)
    {
        memcpy(&streamid, parms+(4*i), 4); /* changed from 2 to 4, bug reported by n.ojanen */
        myStream = findStreamProfile(streamid); 
        if(myStream == NULL)
        {
            status = STATUS_INVALID;
            DPRINT_ERR(WFA_ERR, "Failed to find the stream\n");
            return status;    
        }

        theProfile = &myStream->profile;
        if(theProfile == NULL)
        {
           status = STATUS_INVALID;
           DPRINT_ERR(WFA_ERR, "Failed to find the profile\n");
           return status;
        }

        /* calculate the frame interval which is used to derive its jitter */
        if(theProfile->rate != 0 && theProfile->rate < 5000)
           myStream->fmInterval = 1000000/theProfile->rate; /* in ms */
        else
           myStream->fmInterval = 0;

        if(theProfile->direction != DIRECT_RECV)
        {
           status = STATUS_INVALID;
           return status;
        }

        memset(&myStream->stats, 0, sizeof(tgStats_t));

        // !!!! hack !!!
        hasRecv = 1;
        printf("*******************  Recv Starts here *********************\n");

        // mark the stream active
        myStream->state = WFA_STREAM_ACTIVE;
       
        switch(theProfile->profile)
        {
            case PROF_MCAST:
            status = STATUS_COMPLETE;
            thisSockfd = btSockfd = wfaCreateUDPSock(theProfile->dipaddr, theProfile->dport);
            if(btSockfd >= 0)
            {
                gtgRecv = streamid;
            }
            else
            {
                status = STATUS_ERROR;
                wfaEncodeTLV(WFA_TRAFFIC_AGENT_RECV_START_RESP_TLV, 4, (BYTE *)&status, respBuf);
                *respLen = WFA_TLV_HDR_LEN + 4;

                return WFA_SUCCESS;
                break;
            }

            /* set multicast socket option for receiver */
            so = wfaSetSockMcastRecvOpt(btSockfd, theProfile->dipaddr);
            if(so < 0)
            {
                perror("set mcastat: ");
                DPRINT_ERR(WFA_ERR, "setsockopt at %: ", theProfile->dipaddr);
                CLOSE(btSockfd);
                gtgRecv = 0;
                status = STATUS_ERROR;
                wfaEncodeTLV(WFA_TRAFFIC_AGENT_RECV_START_RESP_TLV, 4, (BYTE *)&status, respBuf);
                *respLen = WFA_TLV_HDR_LEN + 4;

                return WFA_SUCCESS;
            }
            break;

            case PROF_TRANSC:
            gtgTransac = streamid;

            wmm_thr[usedThread].thr_flag = streamid;
            DPRINT_INFOL(WFA_OUT, "usedThread %i\n", usedThread);
            DPRINT_INFOL(WFA_OUT, "\r\nFired thread %d\n",usedThread);
            DPRINT_INFOL(WFA_OUT, "\r\nThread %d flag is %d\n",usedThread,wmm_thr[usedThread].thr_flag);
            ReleaseMutex(wmm_thr[usedThread].thr_flag_mutex);
            Sleep(10);
            ReleaseMutex(wmm_thr[usedThread].thr_flag_mutex);

            usedThread++;
            break;

            case PROF_FILE_TX:
            case PROF_IPTV:
#ifdef WFA_WMM_EXT
            /*
             * singal the thread to Sending WMM traffic 
             */
         
            wmm_thr[usedThread].thr_flag = streamid;

#ifdef _WINDOWS
            DPRINT_INFOL(WFA_OUT, "usedThread %i\n", usedThread);
            DPRINT_INFOL(WFA_OUT, "\r\nFired thread %d\n",usedThread);
            DPRINT_INFOL(WFA_OUT, "\r\nThread %d flag is %d\n",usedThread,wmm_thr[usedThread].thr_flag);
            ReleaseMutex(wmm_thr[usedThread].thr_flag_mutex);
            Sleep(10);
            ReleaseMutex(wmm_thr[usedThread].thr_flag_mutex);
#else
            pthread_mutex_lock(&wmm_thr[usedThread].thr_flag_mutex);
            pthread_cond_signal(&wmm_thr[usedThread].thr_flag_cond);
            pthread_mutex_unlock(&wmm_thr[usedThread].thr_flag_mutex;
#endif
      
            usedThread++;
#endif

#if 0
#ifdef WFA_WMM_EXT
            DPRINT_INFO(WFA_OUT, "Recv start stream id %i port %i\n", streamid, theProfile->dport); 
            status = STATUS_COMPLETE;
            thisSockfd = tgSockfds[myStream->tblidx] = wfaCreateUDPSock(theProfile->dipaddr, theProfile->dport);

            if(thisSockfd >= 0)
               gtgRecv = streamid;
            else
               status = STATUS_ERROR;
#else
            DPRINT_ERR(WFA_ERR, "Incorrect profile, not supported, may need recompile\n");
            status = STATUS_ERROR;
#endif
#endif
            break;
#if 0
            case PROF_TRANSC:
            case PROF_START_SYNC:
            status = STATUS_COMPLETE;
            printf("Starting TRANSAC RECV \n");
//            thisSockfd = btSockfd = wfaCreateUDPSock(theProfile->sipaddr, theProfile->sport);  
            txSockfd = wfaCreateUDPSock(theProfile->sipaddr, theProfile->sport);
            totalTranPkts = 0xFFFFFFF0;
            sentTranPkts = 0;
            if(txSockfd > 0) // btSockfd > 0
            {
               printf("Transac Socket %i\n", txSockfd);
               gtgTransac = streamid;        
               gtgRecv = streamid;
            }
            else
            {
               status = STATUS_ERROR;
            }


            break;
#endif
       
            case PROF_UAPSD:
#ifdef WFA_WMM_EXT
#ifdef WFA_WMM_PS_EXT
            status = STATUS_COMPLETE;
            psSockfd = wfaCreateUDPSock(theProfile->dipaddr, WFA_WMMPS_UDP_PORT);

            wmmps_info.sta_state = 0;
            wmmps_info.wait_state = WFA_WAIT_STAUT_00;

            memset(&wmmps_info.psToAddr, 0, sizeof(wmmps_info.psToAddr));
            wmmps_info.psToAddr.sin_family = AF_INET;
            wmmps_info.psToAddr.sin_addr.s_addr = inet_addr(theProfile->sipaddr);
            wmmps_info.psToAddr.sin_port = htons(theProfile->sport);
            wmmps_info.reset = 0;

            wmm_thr[usedThread].thr_flag = streamid;
            wmmps_info.streamid = streamid;
            pthread_mutex_lock(&wmm_thr[usedThread].thr_flag_mutex);
            pthread_cond_signal(&wmm_thr[usedThread].thr_flag_cond);
            gtgWmmPS = streamid;;
            pthread_mutex_unlock(&wmm_thr[usedThread].thr_flag_mutex);
            usedThread++;

            gtimeOut = MINISECONDS/10;  /* in msec */
            gRegSec = 0;
#endif   /* WFA_WMM_PS_EXT */
#endif   /* WFA_WMM_EXT */
            break;
       }
    }

#ifdef _WINDOWS
    if(thisSockfd >=0)
    {
        if (getsockopt(thisSockfd, SOL_SOCKET, SO_RCVBUF, (char*)&iOptVal, &iOptLen) != SOCKET_ERROR) 
        {
            DPRINT_INFOL(WFA_OUT, "Default SO_RECVBUF Value: %ld\n", iOptVal);
        }

        iOptVal = iOptVal*20;
        //setsockopt(thisSockfd, SOL_SOCKET, SO_RCVBUF, (char*)&iOptVal, iOptLen);

        if (getsockopt(thisSockfd, SOL_SOCKET, SO_RCVBUF, (char*)&iOptVal, &iOptLen) != SOCKET_ERROR) 
        {
           DPRINT_INFOL(WFA_OUT, "New SO_RECVBUF Value: %ld\n", iOptVal);
        }

        SetThreadPriority((HANDLE)recvThr, THREAD_PRIORITY_ABOVE_NORMAL);
        ReleaseMutex(recv_mutex);
    }

    //ReleaseMutex(recv_mutex);
    DPRINT_INFOL(WFA_OUT, "End of RecvStart\n");
#endif
    /* encode a TLV for response for "complete/error ..." */
    wfaEncodeTLV(WFA_TRAFFIC_AGENT_RECV_START_RESP_TLV, sizeof(int), 
                 (BYTE *)&status, respBuf);
    *respLen = WFA_TLV_HDR_LEN + sizeof(int); 

    return WFA_SUCCESS;
}

/*
 * tgRecvStop: instruct traffic generator to stop receiving based on a profile
 * input:      cmd -- not used
 * response:   inform controller for "complete"
 * return:     success or failed 
 */
int wfaTGRecvStop(int len, BYTE *parms, int *respLen, BYTE *respBuf)
{
    int status = STATUS_COMPLETE, i;
    int numStreams = len/4;
    int streamid;
    tgProfile_t *theProfile;
    tgStream_t *myStream=NULL;
    dutCmdResponse_t statResp;
    BYTE dutRspBuf[WFA_BUFF_4K];
    int id_cnt = 0;
#ifdef WFA_WMM_EXT
    FILE *e2eoutp = NULL;
    int rdirect = DIRECT_RECV;
#endif

    DPRINT_INFO(WFA_OUT, "Entering ... with length %d\n",len);
    /*
     * After finishing the receiving command, it should lower itself back to 
     * normal level. It is optional implementation if it is not called 
     * while it starts receiving for raising priority level.
     */
    //wfaSetProcPriority(30);
    memset(dutRspBuf, 0, WFA_BUFF_1K);

    for(i=0; i<numStreams; i++)
    {
        memcpy(&streamid, parms+(4*i), 4);
        myStream = findStreamProfile(streamid); 
        if(myStream == NULL)
        {
            status = STATUS_INVALID;
            wfaEncodeTLV(WFA_TRAFFIC_AGENT_RECV_STOP_RESP_TLV, 4, (BYTE *)&status, respBuf);
            *respLen = WFA_TLV_HDR_LEN + 4;
            return WFA_SUCCESS;    
        }

        theProfile = &myStream->profile;
        if(theProfile == NULL)
        {
           status = STATUS_INVALID;
           wfaEncodeTLV(WFA_TRAFFIC_AGENT_RECV_STOP_RESP_TLV, 4, (BYTE *)&status, respBuf);
           *respLen = WFA_TLV_HDR_LEN + 4;

           return WFA_SUCCESS;
        }

        if(theProfile->direction != DIRECT_RECV)
        {
           status = STATUS_INVALID;
           wfaEncodeTLV(WFA_TRAFFIC_AGENT_RECV_STOP_RESP_TLV, 4, (BYTE *)&status, respBuf);
           *respLen = WFA_TLV_HDR_LEN + 4;

           return WFA_SUCCESS;
        }

        /* reset its flags , close sockets */
        switch(theProfile->profile)
        {
#if 0
            case PROF_FILE_TX:
            gtgRecv = 0;
            //CLOSE(btSockfd);
            //btSockfd = -1;
            break;

            case PROF_MCAST:
            gtgRecv = 0;
            //CLOSE(btSockfd);
            //btSockfd = -1;
            break;
#endif
            case PROF_TRANSC:
            gtgTransac = 0;

            case PROF_FILE_TX:
            case PROF_MCAST:
            case PROF_IPTV:
            DPRINT_INFOL(WFA_OUT, "rec stop %i\n",  streamid);
            WaitForSingleObject( recv_mutex, 50 );

            DPRINT_INFOL(WFA_OUT, "acquired mutex after stop\n");
            Sleep(20);
            gtgRecv = 0;
//#ifdef WFA_WMM_EXT
            
            DPRINT_INFOL(WFA_OUT, "rec stop %i\n",  streamid);
            if(tgSockfds[myStream->tblidx] != -1)
            {
                int iOptVal = 8192;
                int iOptLen = sizeof(int);
                
                // reset the buffer size
                //setsockopt(tgSockfds[myStream->tblidx], SOL_SOCKET, SO_RCVBUF, (char*)&iOptVal, iOptLen);

                CLOSE(tgSockfds[myStream->tblidx]);
                tgSockfds[myStream->tblidx] = -1;
            }

#if 0
            /* the following to report the result.
             * the upload command will send the records back to TM
             */
            gettimeofday(&currtime, NULL);

#ifndef _WINDOWS
            sprintf(e2eResults, "/tmp/e2e%u.txt", (unsigned int) currtime.tv_sec); 
#else
            sprintf(e2eResults, "c:\\windows\\temp\\e2e%u.txt", (unsigned int) currtime.tv_sec); 
#endif
            e2eoutp = fopen(e2eResults, "w+");
            if(e2eoutp != NULL)
            {
               DPRINT_INFO(WFA_OUT, "e2eCnt %i filename %s lost pkts %i\n", e2eCnt, e2eResults,myStream->stats.lostPkts);
               fprintf(e2eoutp, "roundtrip delay: %i\n", (int) (1000000*gtgPktRTDelay)); 
               for(j = 0; j< e2eCnt; j++)
               {
                  fprintf(e2eoutp, "%i:%i:%i:%i:%i\n", e2eStats[j].seqnum, e2eStats[j].lsec, e2eStats[j].lusec, e2eStats[j].rsec, e2eStats[j].rusec);
               }
               fclose(e2eoutp);
            }
            else
            {
               DPRINT_ERR(WFA_ERR, "Failed to open file to store test records.");
            }

            e2eCnt = 0;
            memset(e2eStats, 0, 6000*sizeof(tgE2EStats_t));
#endif
//#endif
            break;
#if 0
            case PROF_TRANSC:
            case PROF_START_SYNC:
            gtgTransac = 0;        
            gtgRecv = 0;
           // CLOSE(btSockfd);
           // btSockfd = -1;
            CLOSE(txSockfd);
            txSockfd = -1;
            break;
#endif

            case PROF_UAPSD:
#ifdef WFA_WMM_EXT
#ifdef WFA_WMM_PS_EXT
            gtgWmmPS = 0;
            gtgPsPktRecvd = 0;

            if(psSockfd != -1)
            {
               CLOSE(psSockfd);
               psSockfd = -1;
            }

            memset(&wmmps_info, 0, sizeof(wfaWmmPS_t));

            wfaSetDUTPwrMgmt(PS_OFF);
#endif
#endif
            break;

        }
//         SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
        
        /* encode a TLV for response for "complete/error ..." */
        statResp.status = STATUS_COMPLETE; 
        statResp.streamId = streamid; 

#if 1
        DPRINT_INFOL(WFA_OUT, "Recv stream Id %i rx %lu total %llu \n", streamid, myStream->stats.rxFrames, myStream->stats.rxPayloadBytes);
#endif
        memcpy(&statResp.cmdru.stats, &myStream->stats, sizeof(tgStats_t));
        memcpy((dutRspBuf + i * sizeof(dutCmdResponse_t)), (BYTE *)&statResp, sizeof(dutCmdResponse_t));
        id_cnt++;
        DPRINT_INFOL(WFA_OUT, "Size of a stream is %d\n",sizeof(tgStream_t));
        // Not empty it but require to reset the entire table before test starts.
        //memset(myStream, 0, sizeof(tgStream_t));
    }

//    WaitForSingleObject( recv_mutex, INFINITE );
// DPRINT_INFO(WFA_OUT, "acquired mutex after stop\n");

    // mark the stream inactive
    myStream->state = WFA_STREAM_INACTIVE;
    wfaEncodeTLV(WFA_TRAFFIC_AGENT_RECV_STOP_RESP_TLV, id_cnt * (int) sizeof(dutCmdResponse_t),    dutRspBuf, respBuf);

    /* done here */
    *respLen = WFA_TLV_HDR_LEN + numStreams * sizeof(dutCmdResponse_t); 
    //CreateThread(NULL, 0, wfa_traffic_resend_results_thread, (PVOID)&rdirect, 0, &thr_id);

    return WFA_SUCCESS;
}

/*
 * vhtTGSendStart()
 *    This is designed to use multiple socket streams to generate enough traffic volumn for VHT 
 *
 */


/*
 * wfaTGSendStart: instruct traffic generator to start sending based on a profile
 * input:      cmd -- not used
 * response:   inform controller for "running"
 * return:     success or failed 
 */
int wfaTGSendStart(int len, BYTE *parms, int *respLen, BYTE *respBuf)
{
    int i=0, streamid=0, so;
    int numStreams = len/4;

    tgProfile_t *theProfile;
    tgStream_t *myStream = NULL;
#ifdef _WINDOWS
    int iOptVal;
    int iOptLen = sizeof(int);
#endif

#ifdef WFA_WMM_EXT
//    struct timeval btime;
#endif
    dutCmdResponse_t staSendResp;

    DPRINT_INFOL(WFA_OUT, "Entering ... for %i streams ...\n", numStreams);
    for(i=0; i<numStreams; i++)
    {
        memcpy(&streamid, parms+(4*i), 4);
        DPRINT_INFOL(WFA_OUT, "Streamid to look for is %d\n",streamid);
        myStream = findStreamProfile(streamid); 
        if(myStream == NULL)
        {
           staSendResp.status = STATUS_INVALID;
           wfaEncodeTLV(WFA_TRAFFIC_AGENT_SEND_RESP_TLV, 4, (BYTE *)&staSendResp, respBuf);
           *respLen = WFA_TLV_HDR_LEN + 4;
           return WFA_SUCCESS;
        }

        theProfile = &myStream->profile;
        if(theProfile == NULL)
        {
           staSendResp.status = STATUS_INVALID;
           wfaEncodeTLV(WFA_TRAFFIC_AGENT_SEND_RESP_TLV, 4, (BYTE *)&staSendResp, respBuf);
           *respLen = WFA_TLV_HDR_LEN + 4;

           return WFA_SUCCESS;
        }
               
        if(theProfile->direction != DIRECT_SEND)
        {
           staSendResp.status = STATUS_INVALID;
           wfaEncodeTLV(WFA_TRAFFIC_AGENT_SEND_RESP_TLV, 4, (BYTE *)&staSendResp, respBuf);
           *respLen = WFA_TLV_HDR_LEN + 4;

           return WFA_SUCCESS;
        }

        /*
         * need to reset the stats
         */
        memset(&myStream->stats, 0, sizeof(tgStats_t));

        // mark the stream active;
        myStream->state = WFA_STREAM_ACTIVE;

        switch(theProfile->profile)
        {
           case PROF_FILE_TX:
           if(theProfile->hti == WFA_ON)
           {
                
           }
           else
           {
               btSockfd = wfaCreateUDPSock(theProfile->sipaddr, theProfile->sport);
               if((btSockfd=wfaConnectUDPPeer(btSockfd, theProfile->dipaddr, theProfile->dport)) > 0)
               {
                   gtgSend = streamid;
               }
               else
               {
                   staSendResp.status = STATUS_ERROR;
                   wfaEncodeTLV(WFA_TRAFFIC_AGENT_SEND_RESP_TLV, 4, (BYTE *)&staSendResp, respBuf);
                   *respLen = WFA_TLV_HDR_LEN + 4;

                   return WFA_SUCCESS;
               }
           }
           //wfaSetProcPriority(60);
           break;

           case PROF_MCAST:
           btSockfd = wfaCreateUDPSock(theProfile->sipaddr, theProfile->sport);
           if(btSockfd)
           {
               gtgSend = streamid;
           }
           else
           {
               staSendResp.status = STATUS_ERROR;

               wfaEncodeTLV(WFA_TRAFFIC_AGENT_SEND_RESP_TLV, 4, (BYTE *)&staSendResp, respBuf);
               *respLen = WFA_TLV_HDR_LEN + 4;

               return WFA_SUCCESS;
           }

           so = wfaSetSockMcastSendOpt(btSockfd);
           if (so < 0)
           {
               DPRINT_ERR(WFA_ERR, "setsockopt for mcast: ");
               gtgSend = 0;
               CLOSE(btSockfd);
               btSockfd = -1;
               staSendResp.status = STATUS_ERROR;

               wfaEncodeTLV(WFA_TRAFFIC_AGENT_SEND_RESP_TLV, 4, (BYTE *)&staSendResp, respBuf);
               *respLen = WFA_TLV_HDR_LEN + 4;

                return WFA_SUCCESS;
            }
            //wfaSetProcPriority(60)
            break;
            case PROF_IPTV:
#ifdef WFA_WMM_EXT
            /*
             * singal the thread to Sending WMM traffic 
             */
         
            wmm_thr[usedThread].thr_flag = streamid;
            mainSendThread = usedThread;

#ifdef _WINDOWS
            DPRINT_INFOL(WFA_OUT, "usedThread %i\n", usedThread);
            DPRINT_INFOL(WFA_OUT, "\r\nFired thread %d\n",usedThread);
            DPRINT_INFOL(WFA_OUT, "\r\nThread %d flag is %d\n",usedThread,wmm_thr[usedThread].thr_flag);
            ReleaseMutex(wmm_thr[usedThread].thr_flag_mutex);
            Sleep(10);
            ReleaseMutex(wmm_thr[usedThread].thr_flag_mutex);
#else
            pthread_mutex_lock(&wmm_thr[usedThread].thr_flag_mutex);
            pthread_cond_signal(&wmm_thr[usedThread].thr_flag_cond);
            pthread_mutex_unlock(&wmm_thr[usedThread].thr_flag_mutex
#endif
      
            usedThread++;
            //wfaSetProcPriority(90);
            //SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);

#endif
            break;

            case PROF_TRANSC:
            {
               btSockfd = wfaCreateUDPSock(theProfile->sipaddr, theProfile->sport);
               if((btSockfd = wfaConnectUDPPeer(btSockfd, theProfile->dipaddr, theProfile->dport)) > 0)
               {
                   gtgTransac = streamid;        
                   gtgSend = streamid;
                   totalTranPkts = theProfile->rate * theProfile->duration;
                   sentTranPkts = 0;

                   /*
                    * the framerate here is used to derive the timeout 
                    * value for waiting transaction echo responses.
                    */
                   gtimeOut = MINISECONDS/theProfile->rate;  /* in msec */
               }
               else
               {
                   staSendResp.status = STATUS_ERROR;
                   wfaEncodeTLV(WFA_TRAFFIC_AGENT_SEND_RESP_TLV, 4, (BYTE *)&staSendResp, respBuf);
                   *respLen = WFA_TLV_HDR_LEN + 4;

                   return WFA_SUCCESS;
               }

               /* set duration for the test */
#ifndef _WINDOWS
               signal(SIGALRM, tmout_stop_send);
               alarm(theProfile->duration);
#else
               DPRINT_INFOL(WFA_OUT, "\r\n TRANSFIX -Setting timer for %d ms\n",(theProfile->duration)*1000);
               timer_dur = (theProfile->duration)*1000;
               CreateThread(NULL, 0, wfa_wpa2_sleep_thread, (PVOID)&timer_dur, 0,&thr_id);
#endif
            }
            break;
#ifdef WFA_WMM_EXT
            case PROF_START_SYNC:
            {
               DPRINT_INFOL(WFA_OUT, "profile port %i\n", theProfile->sport);
               btSockfd = wfaCreateUDPSock(theProfile->sipaddr, theProfile->sport);
               if((btSockfd = wfaConnectUDPPeer(btSockfd, theProfile->dipaddr, theProfile->dport)) > 0)
               {
                   gtgTransac = streamid;        
                   gtgSend = streamid;
                   totalTranPkts = theProfile->rate * theProfile->duration;
                   sentTranPkts = 0;
                   if(theProfile->profile == PROF_START_SYNC)
                      gtgStartSync = streamid;

                   /*
                    * the framerate here is used to derive the timeout 
                    * value for waiting transaction echo responses.
                    */
                   gtimeOut = MINISECONDS/theProfile->rate;  /* in msec */
               }
               else
               {
                   DPRINT_INFOL(WFA_OUT, "connection failed\n");
               }
 
               /* set duration for the test */
#ifndef _WINDOWS
               signal(SIGALRM, tmout_stop_send);
               alarm(theProfile->duration+1);
#else
            // SetTimer(0, 0, (theProfile->duration +1)*1000, (TIMERPROC)tmout_stop_send);
               DPRINT_INFOL(WFA_OUT, "\r\n SYNCFIX -Setting timer for %d ms\n",(theProfile->duration)*1000);
               timer_dur = (theProfile->duration)*1000;
               CreateThread(NULL, 0, wfa_wpa2_sleep_thread, (PVOID)&timer_dur, 0,&thr_id);

#endif
            }
            break;
#endif
      } // switch
#ifdef _WINDOWS
      if(btSockfd != -1)
      {
         if (getsockopt(btSockfd, SOL_SOCKET, SO_SNDBUF, (char*)&iOptVal, &iOptLen) != SOCKET_ERROR) 
         {
             DPRINT_INFOL(WFA_OUT, "SO_SNDBUF Value: %ld\n", iOptVal);
         }

         iOptVal = iOptVal*40;
    //iOptVal = 262120;

         //setsockopt(btSockfd, SOL_SOCKET, SO_SNDBUF, (char*)&iOptVal, iOptLen);

        if (getsockopt(btSockfd, SOL_SOCKET, SO_SNDBUF, (char*)&iOptVal, &iOptLen) != SOCKET_ERROR) 
        {
            DPRINT_INFOL(WFA_OUT, "SO_SNDBUF Value: %ld\n", iOptVal);
        }
     }
#endif
  } // for

  *respLen = 0;

  return WFA_SUCCESS;
}

int wfaTGReset(int len, BYTE *parms, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *resetResp = &gGenericResp;
    int i;
    DPRINT_INFOL(WFA_OUT, "Entering tgreset for btsok %d ...\n",btSockfd);
    /* need to reset all traffic socket fds */
//    SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
    if(btSockfd != -1)
    {
       CLOSE(btSockfd);
       btSockfd = -1;
    }

    if(txSockfd != -1)
    {
       CLOSE(txSockfd);
       txSockfd = -1;
    }

    for(i=0;i<WFA_MAX_TRAFFIC_STREAMS;i++)
       if(tgSockfds[i] > 0)
       {
          DPRINT_INFOL(WFA_WNG, "Closing a socket which should have been closed earlier\n");
          CLOSE(tgSockfds[i]);
          tgSockfds[i] = -1;
       }

#ifdef resolve
    /* reset the timer alarm if it was armed */
    alarm(0);
#endif
    /* just reset the flags for the command */
    gtgRecv = 0;
    gtgSend = 0;
    gtgTransac = 0;
    totalTranPkts = 0;
    gtimeOut = 0;

    runLoop = 0;

#ifdef WFA_WMM_EXT
    usedThread = 0;
#ifdef WFA_WMM_PS_EXT
    gtgWmmPS = 0;
    gtgPsPktRecvd = 0;

    if(psSockfd != -1)
    {
       close(psSockfd);
       psSockfd = -1;
    }

    memset(&wmmps_info, 0, sizeof(wfaWmmPS_t));

    wfaSetDUTPwrMgmt(PS_OFF);
#endif
    DPRINT_INFOL(WFA_OUT, "before memset...\n");
    gtgStartSync = 0;
    e2eCnt = 0;
    e2eResults[0] = '\0';
    memset(e2eStats, 0, 6000*sizeof(tgE2EStats_t));
#endif

//#ifdef WFA_VHT5G_EXT
    becnt = 0;
//#endif
    /* Also need to clean up WMM streams NOT DONE YET!*/
    slotCnt = 0;             /* reset stream profile container */
    memset(gStreams, 0, WFA_MAX_TRAFFIC_STREAMS*sizeof(tgStream_t));
    DPRINT_INFOL(WFA_OUT, "after memset streams...\n");
    /*
     * After be asked to reset, it should lower itself back to 
     * normal level. It is optional implementation if it is not called 
     * while it starts sending/receiving for raising priority level.
     */
    //wfaSetProcPriority(20);

    /* encode a TLV for response for "complete ..." */
    resetResp->status = STATUS_COMPLETE; 
    wfaEncodeTLV(WFA_TRAFFIC_AGENT_RESET_RESP_TLV, 4, 
                 (BYTE *)resetResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4; 
    DPRINT_INFOL(WFA_OUT, "Exiting tgreset for ...\n");
    return WFA_SUCCESS;
}

/*
 * calculate the sleep time for different frame rate
 * It should be done according the device
 * This is just one way to adjust the packet delivery speed. If you find 
 * you device does not meet the test requirements, you MUST re-adjust 
 * the method.
 */

/* The HZ value could be found in the build header file */
/* 100 -> 10ms, 1000 -> 1ms , etc                       */
#define WFA_KERNEL_MIN_TIMER_RES   100   /* HZ Value for 10 ms */

void wfaTxSleepTime(int profile, int rate, int *sleepTime, int *throttledRate)
{
    *sleepTime=0;     /* in microseconds */
    /* calculate the sleep time based on frame rate */

    /*
     * Framerate is still required for Multicast traffic
     * Sleep and hold for a timeout.
     *
     * For WMM traffic, the framerate must also need for VO and VI.
     * the framerate 500, OS may not handle it precisely.
     */
    switch(profile)
    {
        /*
         * make it a fix rate
         */
        case PROF_MCAST:
#if 0
        if(rate > 100)
            *sleepTime = 100000;  /* sleep for 100 ms */
            *throttledRate = 40;
#endif
        if(rate < 500 && rate >= 50)
        {
            *sleepTime = 100000;  /* sleep for 100 ms */
            *throttledRate = WFA_MCAST_FRATE;
        }
        else
        {
            *sleepTime = 100000;
            *throttledRate = rate;
        }
        break;

        /*
         * Vendor must find ways to better adjust the speed for their own device
         */
        case PROF_IPTV:
        case PROF_FILE_TX:
//        if(rate >=50 || rate == 0)
        if (rate == 0)
        {
           *sleepTime = 20000;
           *throttledRate = 10000/50;
        }
        else if(rate > 50)
        {
           /* 
            * this sleepTime indeed is now being used for time period  
            * to send packets in the throttled Rate.  
            * The idea here is that in each fixed 20 minisecond period,
            * The device will send rate/50 (rate = packets / second),
            * then go sleep for rest of time.
            */
            *sleepTime = 50000; /* fixed 20 miniseconds, changed to 50 */
            //*throttledRate = (rate?rate:100000)/50; // changed from 50 to 20
            //*throttledRate = (rate?rate:0);
            *throttledRate = rate/20;

            DPRINT_INFOL(WFA_OUT, "Sleep time %i, throttledRate %i\n", *sleepTime, *throttledRate);
        }
        else if (rate > 0 && rate <= 50) /* typically for voice */
        {
            *throttledRate = 1;
            *sleepTime = 1000*1000/rate;
        }
        break;
        default:
            DPRINT_ERR(WFA_ERR, "Incorrect profile\n");
     } 
}

#define WFA_TIME_DIFF(before, after, rtime, dtime) \
             dtime = rtime + (after.tv_sec*1000000 + after.tv_usec) - (before.tv_sec*1000000 + before.tv_usec);

void buzz_time(int delay)
{
    struct timeval now, stop;
    int diff;
    int remain_time = 0;

    gettimeofday(&stop, 0);

    stop.tv_usec += delay;
    if(stop.tv_usec > 1000000)
    {
        stop.tv_usec -=1000000;
        stop.tv_sec +=1;
    }
  
    do
    {
        gettimeofday(&now, 0);
        WFA_TIME_DIFF(now, stop, remain_time, diff);
    } while(diff>0);

// gettimeofday(&now, 0);
// DPRINT_INFO(WFA_OUT, "burning delay is %d now sec %d, usec %d early sec %d usec %d\n",delay,now.tv_sec,now.tv_usec,then.tv_sec,then.tv_usec);

}

extern int progSet;

/**************************************************/
/* the actually functions to send/receive packets */
/**************************************************/

/* This is going to be a blocking SEND till it finishes */
int wfaSendLongFile(int mySockfd, int streamid, BYTE *aRespBuf, int *aRespLen)
{
    tgProfile_t           *theProf = NULL;
    tgStream_t            *myStream = NULL;
    struct sockaddr_in    toAddr;
    char                  *packBuf; 
    int  packLen;
    int  bytesSent;
    dutCmdResponse_t sendResp;
    int sleepTime = 0;
    int throttledRate = 0;
    struct timeval before, after,after1,af; 
    int difftime = 0,x;
    int counter = 0;
//    struct timeval stime;
    int throttled_est_cost;
    int act_sleep_time;
    gettimeofday(&af,0);
   
    DPRINT_INFOL(WFA_OUT, "Entering sendLongFile %i at sec %d usec %d\n", streamid,af.tv_sec,af.tv_usec);
    /* find the profile */
    myStream = findStreamProfile(streamid);
    if(myStream == NULL)
    {
        return FALSE;    
    }

    theProf = &myStream->profile;

    if(theProf == NULL)
    {
        return FALSE;
    }

    if(theProf->rate == 0)
    {
		DPRINT_INFOL(WFA_OUT, "Input parameters control - Rate %i and progset %i and hti %i\n", theProf->duration,progSet,theProf->hti);
        if(progSet == eDEF_VHT)  // only for VHT or other high through programs
        {
            if(theProf->hti == WFA_ON)
               packLen = MAX_UDP_LEN;
            else if(theProf->hti == WFA_OFF)
               packLen = MAX_ETH_PAYLOAD_LEN;
			else 
			   packLen = MAX_LEGACY_PAYLOAD_LEN;

        }
        else
       {
            packLen = MAX_LEGACY_PAYLOAD_LEN;
       }
		DPRINT_INFOL(WFA_OUT, "Input parameters control - Rate %i and progset %i and PacketLength %i\n", theProf->duration,progSet,packLen);
    }
    else
         packLen = theProf->pksize;
#if 0   
    if(theProf->trafficClass == TG_WMM_AC_VI)
    {
         packLen = MAX_ETH_PAYLOAD_LEN;
    }
#endif
    /* allocate a buf */
    packBuf = (char *)malloc(packLen+1);
    memset(packBuf, 0, packLen);

    /* fill in the header */
    strncpy(packBuf, "1345678", sizeof(tgHeader_t));

    /* initialize the destination address */
    memset(&toAddr, 0, sizeof(toAddr));
    toAddr.sin_family = AF_INET;
    toAddr.sin_addr.s_addr = inet_addr(theProf->dipaddr);
    toAddr.sin_port = htons(theProf->dport); 

    /* if a frame rate and duration are defined, then we know
     * interval for each packet and how many packets it needs to
     * send.
     */
    if(theProf->duration != 0)
    {
 
        DPRINT_INFOL(WFA_OUT, "duration %i\n", theProf->duration);

        if (theProf->hti == WFA_ON && theProf->rate == 0)
        {
#if 1
           /* experiment for VHT */
           sleepTime = 50;
           if(becnt != 0)
               throttledRate = 700/20;
           else
               throttledRate = 800/20;

           becnt++;
#endif
           DPRINT_INFOL(WFA_OUT, "running with HTI and rate 0\n");
        }
        else
//                if(theProf->hti == WFA_OFF|| theProf->rate != 0)
        {
        /* 
         *  use this to decide periodical interval sleep time and frames to send
         *  int the each interval.
         *  Each device should adopt a own algorithm for better performance
         */
             wfaTxSleepTime(theProf->profile, theProf->rate, &sleepTime, &throttledRate);
        }
        /* 
         * alright, we need to raise the priority level of the process
         * to improve the real-time performance of packet sending.
         * Since this is for tuning purpose, it is optional implementation.
         */
        //wfaSetProcPriority(60);
 
        //interval = 1*1000000/theProf->rate ; // in usec;

        // Here assumes it takes 20 usec to send a packet
        throttled_est_cost = throttledRate * 20;  // MUST estimate the cost per ppk
        act_sleep_time = sleepTime - adj_latency;
        if (act_sleep_time <= 0)
            act_sleep_time = sleepTime;  

        DPRINT_INFOL(WFA_OUT, "sleep time %i act_sleep_time %i\n", sleepTime, act_sleep_time);

        runLoop=1;
         
        while(runLoop)
        {
   
#ifdef _WINDOWS_OLD
           MSG msg = { 0, 0, 0, 0 };
           if(PeekMessage(&msg,NULL,0,0,PM_REMOVE))
           {
              if(msg.message == WM_TIMER)
              {
                 TranslateMessage (&msg);
                 DispatchMessage(&msg);
              }
              DPRINT_INFO(WFA_OUT,  "\r\n Timer DONE for packlen %d\n",packLen);
              msg.message = 0;
           }
#endif
           if(packLen == 1001)
              x=1;

           counter++;
           /* fill in the counter */
           int2BuffBigEndian(counter, &((tgHeader_t *)packBuf)->hdr[8]);

           /*
            * the following code is only used to slow down
            * over fast traffic flooding the buffer and cause
            * packet drop or the other end not able to receive due to
            * some limitations, purely for experiment purpose.
            * each implementation needs some fine tune to it.
            */
           if(counter ==1)
           {
              gettimeofday(&before, NULL);

              before.tv_usec += sleepTime;
              if(before.tv_usec > 1000000)
              {
                  before.tv_usec -= 1000000;
                  before.tv_sec +=1;
              }
           }

           if(throttledRate != 0)
           {
              if(counter%throttledRate == 0)
              {
                 gettimeofday(&after, NULL);
                 difftime = wfa_itime_diff(&after, &before);

                 if(difftime > adj_latency)
                 {
#ifdef _WINDOWS
                    // too much time left, go sleep
                    //printf("\r\n Sleeping for %d time", (difftime-adj_latency)/1000);
                    Sleep((difftime-adj_latency)/10000);
#else
                    usleep((difftime-adj_latency);
#endif
                    gettimeofday(&after1, NULL);
                    difftime = wfa_itime_diff(&after1, &before);
                }

                // burn the rest to absort latency
                if(difftime >0)
                    buzz_time(difftime);

                before.tv_usec += sleepTime;
                if(before.tv_usec > 1000000)
                {
                   before.tv_usec -= 1000000;
                   before.tv_sec +=1;
                }
             }
          } // otherwise, it floods 

#if 0
          /*
           * Fill the timestamp to the header.
           */
          gettimeofday(&stime, NULL);

          int2BuffBigEndian(stime.tv_sec, &((tgHeader_t *)packBuf)->hdr[12]);
          int2BuffBigEndian(stime.tv_usec, &((tgHeader_t *)packBuf)->hdr[16]);
#endif    

          if(throttledRate == 0)
          {

          }
          else
          {

          }

          bytesSent = wfaTrafficSendTo(mySockfd, packBuf, packLen, 
            (struct sockaddr *)&toAddr);
          if(bytesSent != -1)
          {
             myStream->stats.txPayloadBytes += bytesSent; 
             myStream->stats.txFrames++ ;
          }
          else
          {
#ifdef _WINDOWS
             int errsv = WSAGetLastError();
             switch(errsv)
             {
                 case WSAENOBUFS:
                 DPRINT_ERR(WFA_ERR, "send error\n");
                 Sleep(1);             /* hold for 1 ms */
                 counter-- ;
                 myStream->stats.txFrames--;
                 break;

                 case WSAECONNRESET:
                 DPRINT_ERR(WFA_ERR, "send error RESET\n");
                 runLoop = 0;
                 break;

                 case WSAENOTCONN:
                 DPRINT_ERR(WFA_ERR, "send error not connected\n");
                 runLoop = 0;
                 break;

                 case WSANOTINITIALISED:
                 DPRINT_ERR(WFA_ERR, "WSAStartup not yet called\n");
                 break;

                 default:
                 DPRINT_ERR(WFA_ERR, "Packet sent error %d\n",errsv);
                 Sleep(20);
             }
#else
             int errsv = errno;
             switch(errsv)
             {
                 case EAGAIN:
                 case ENOBUFS:
                 DPRINT_ERR(WFA_ERR, "send error\n");
                 usleep(1000);             /* hold for 1 ms */
                 counter-- ;
                 myStream->stats.txFrames--;
                 break;

                 case ECONNRESET:
                 runLoop = 0;
                 break;

                 case EPIPE:
                 runLoop = 0;
                 break;

                 default:
                 perror("sendto: ");
                 DPRINT_ERR(WFA_ERR, "Packet sent error\n");
             }
#endif

           }

        } /* while */

        /*
         * lower back to an original level if the process is raised previously
         * It is optional.
         */
        //wfaSetProcPriority(30); 
    } /* if ->duration */
    else /* invalid parameters */
    {
        /* encode a TLV for response for "invalid ..." */
        sendResp.status = STATUS_INVALID;
        wfaEncodeTLV(WFA_TRAFFIC_AGENT_SEND_RESP_TLV, 4, 
                 (BYTE *)&sendResp, (BYTE *)aRespBuf);

        /* done here */
        *aRespLen = WFA_TLV_HDR_LEN + 4; 

        free(packBuf);

        return DONE;
    }

    gtgSend = 0;

    /* free the buffer */
    free(packBuf);

    //printf("done sending long\n");
    /* return statistics */
    sendResp.status = STATUS_COMPLETE;
    sendResp.streamId = myStream->id;
    DPRINT_INFOL(WFA_OUT, "\r\n Sent frames are %d\n",myStream->stats.txFrames);
    memcpy(&sendResp.cmdru.stats, &myStream->stats, sizeof(tgStats_t)); 

    wfaEncodeTLV(WFA_TRAFFIC_AGENT_SEND_RESP_TLV, sizeof(dutCmdResponse_t), 
                 (BYTE *)&sendResp, (BYTE *)aRespBuf);

    *aRespLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

    //system("iwpriv ath2 sleep 0"); /* make it always sleep */
   
    return DONE;
}

/* this only sends one packet a time */
int wfaSendShortFile(int mySockfd, int streamid, BYTE *sendBuf, int pksize, BYTE *aRespBuf, int *aRespLen)
{
   BYTE *packBuf = sendBuf; 
   struct sockaddr_in toAddr;
   tgProfile_t *theProf;
   tgStream_t *myStream;
   int packLen, bytesSent=-1;
   dutCmdResponse_t sendResp;

   if(mySockfd == -1)
   {
      /* stop */ 
      gtgTransac = 0;
      gtimeOut = 0; 
      gtgRecv = 0;
      gtgSend = 0;
      DPRINT_INFOL(WFA_OUT, "stop short traffic\n");

      myStream = findStreamProfile(streamid);
      if(myStream != NULL)
      {
          sendResp.status = STATUS_COMPLETE;
          sendResp.streamId = streamid;
          memcpy(&sendResp.cmdru.stats, &myStream->stats, sizeof(tgStats_t)); 
    
          wfaEncodeTLV(WFA_TRAFFIC_AGENT_SEND_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)&sendResp, aRespBuf);

          *aRespLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
      }

      return -1;
   }

   /* find the profile */
   myStream = findStreamProfile(streamid);

   theProf = &myStream->profile;
   if(theProf == NULL)
   {
        return WFA_FAILURE;
   }

   if(pksize == 0)
      packLen = theProf->pksize;
   else
      packLen = pksize;

   memset(&toAddr, 0, sizeof(toAddr));
   toAddr.sin_family = AF_INET;
   toAddr.sin_addr.s_addr = inet_addr(theProf->sipaddr);
   toAddr.sin_port = htons(theProf->sport); 

   if(gtgRecv && gtgTransac)
   {
      toAddr.sin_addr.s_addr = inet_addr(theProf->sipaddr);
      toAddr.sin_port = htons(theProf->sport); 
   }
   else if(gtgSend && gtgTransac)
   {
      toAddr.sin_addr.s_addr = inet_addr(theProf->dipaddr);
      toAddr.sin_port = htons(theProf->dport); 
   }

   int2BuffBigEndian(myStream->stats.txFrames, &((tgHeader_t *)packBuf)->hdr[8]);

   if(mySockfd != -1)
      bytesSent = wfaTrafficSendTo(mySockfd, (char *)packBuf, packLen, (struct sockaddr *)&toAddr);


   if(bytesSent != -1)
   {
//      printf("Short Pkt sent\n");
      myStream->stats.txFrames++;
      myStream->stats.txPayloadBytes += bytesSent;
   }
   else
   {
#ifdef _WINDOWS
      int errsv = WSAGetLastError();
      switch(errsv)
      {
          case WSAENOBUFS:
          DPRINT_ERR(WFA_ERR, "send error\n");
          Sleep(1);             /* hold for 1 ms */
          myStream->stats.txFrames--;
          break;

          case WSAECONNRESET:
          runLoop = 0;
          break;

          case WSAENOTCONN:
          runLoop = 0;
          break;

          case WSANOTINITIALISED:
          DPRINT_ERR(WFA_ERR, "WSAStartup not yet called\n");
          break;

          default:
          DPRINT_ERR(WFA_ERR, "Packet sent error\n");
      
      }
#else
      int errsv = errno;
      switch(errsv)
      {
          case EAGAIN:
          case ENOBUFS:
          DPRINT_ERR(WFA_ERR, "send error\n");
          usleep(1000);             /* hold for 1 ms */
          myStream->stats.txFrames--;
          break;
          default:
             perror("sendto: ");
      }
#endif
   }

   sentTranPkts++;

   return WFA_SUCCESS;
}

/* always receive from a specified IP address and Port */
int wfaRecvFile(int mySockfd, int streamid, char *recvBuf)
{
    /* how many packets are received */  
    char *packBuf = recvBuf; 
    struct sockaddr_in fromAddr;
    tgProfile_t *theProf;
    tgStream_t *myStream;
    unsigned int bytesRecvd;
//    int ioflags;
    int lostPkts;
#ifdef _WINDOWS
    u_long NonBlock=0; // make it block
#endif
    /* find the profile */
    myStream = findStreamProfile(streamid);

    theProf = &myStream->profile;
    if(theProf == NULL)
    {
        return WFA_FAILURE;
    }

    memset(packBuf, 0, MAX_RCV_BUF_LEN);

    memset(&fromAddr, 0, sizeof(fromAddr));
    fromAddr.sin_family = AF_INET;
    fromAddr.sin_addr.s_addr = inet_addr(theProf->dipaddr);
    fromAddr.sin_port = htons(theProf->dport); 

    if(gtgRecv && gtgTransac)
    {
       fromAddr.sin_addr.s_addr = inet_addr(theProf->sipaddr);
       fromAddr.sin_port = htons(theProf->sport); 
    }
    else if(gtgSend && gtgTransac)
    {
       fromAddr.sin_addr.s_addr = inet_addr(theProf->dipaddr);
       fromAddr.sin_port = htons(theProf->dport); 
    }

 if (ioctlsocket(mySockfd, FIONBIO, &NonBlock) == SOCKET_ERROR)
     {
//          DPRINT_INFO(WFA_OUT, "ioctlsocket() failed \n");
          return -1;
     }
    /* it is always to receive at least one packet, in case more in the
       queue, just pick them up.
     */
    bytesRecvd = wfaTrafficRecv(mySockfd, packBuf, (struct sockaddr *)&fromAddr);

    if(!gtgTransac)
    {
        while(bytesRecvd != -1)
        {
#ifdef WFA_WMM_EXT
            int le2eCnt = myStream->stats.rxFrames;
            tgE2EStats_t *e2esp = myStream->e2ebuf;

            int totalE2Cnt = 6000;
#endif
            myStream->stats.rxFrames++;    
            myStream->stats.rxPayloadBytes +=bytesRecvd;

            /*
             *  Get the lost packet count
             */
            lostPkts =bigEndianBuff2Int(&((tgHeader_t *)packBuf)->hdr[8]) - 1 - myStream->lastPktSN; 
            myStream->stats.lostPkts += lostPkts; 
            myStream->lastPktSN = bigEndianBuff2Int(&((tgHeader_t *)packBuf)->hdr[8]); 

#ifdef WFA_WMM_EXT
            if(theProf->profile == PROF_IPTV)
            {
                struct timeval ttval, currTimeVal;

                int sn = bigEndianBuff2Int(&((tgHeader_t *)recvBuf)->hdr[8]);
                ttval.tv_sec = bigEndianBuff2Int(&((tgHeader_t *)recvBuf)->hdr[12]);
                ttval.tv_usec = bigEndianBuff2Int(&((tgHeader_t *)recvBuf)->hdr[16]);
                gettimeofday(&currTimeVal, NULL);

                /*
                 * take the end2end stats, limit to the max voice pkt number
                 */
//                DPRINT_INFO(WFA_OUT, "receive the %i packet\n", le2eCnt);

                if(le2eCnt < totalE2Cnt)
                {
                    tgE2EStats_t *ep = e2esp + le2eCnt;
                    ep->seqnum = sn;
                    ep->rsec = ttval.tv_sec;
                    ep->rusec = ttval.tv_usec;

                    ep->lsec = currTimeVal.tv_sec;
                    ep->lusec = currTimeVal.tv_usec;

                    if(ep->lusec  < 0)
                    {
                       ep->lsec -=1;
                       ep->lusec += 1000000;
                    }
                    else if(ep->lusec >= 1000000)
                    {
                       ep->lsec += 1;
                       ep->lusec -= 1000000;
                    }
                }
             }
#endif
             bytesRecvd = wfaTrafficRecv(mySockfd, packBuf, (struct sockaddr *)&fromAddr);

#ifdef _WINDOWS
             if (bytesRecvd == 0)
                 SwitchToThread();
#endif
         }  
    } 

    if(bytesRecvd != -1)
    {
         myStream->stats.rxFrames++;    
         myStream->stats.rxPayloadBytes +=bytesRecvd;

             /*
              *  Get the lost packet count
              */
         lostPkts =bigEndianBuff2Int(&((tgHeader_t *)packBuf)->hdr[8]) - 1 - myStream->lastPktSN; 
         myStream->stats.lostPkts += lostPkts; 
         myStream->lastPktSN = bigEndianBuff2Int(&((tgHeader_t *)packBuf)->hdr[8]); 
 
         // just for verify INTEL
    }

    return (bytesRecvd);
}

void  wfaRecvStatsResp(int sock, BYTE *buf)
{
   int i, total=0, pkLen;
   tgStream_t *allStreams = gStreams;
   dutCmdResponse_t *recvStatsResp = (dutCmdResponse_t *)buf, *first;
   char buff[WFA_BUFF_4K];
   DPRINT_INFOL(WFA_OUT, "wfaRecvStatsResp: gstream is %d\n",gStreams);
   if(recvStatsResp == NULL)
      return;

   first = recvStatsResp;
 
   for(i = 0; i < WFA_MAX_TRAFFIC_STREAMS; i++)
   {
      if((allStreams->id != 0) && (allStreams->profile.direction == DIRECT_RECV) && (allStreams->state == WFA_STREAM_ACTIVE))
      {
#if 1
          DPRINT_INFOL(WFA_OUT, "id=%i rxFrames=%i txFrames=%i rxPayLoadBytes=%i txPayloadBytes=%i\n", allStreams->id,
                                  allStreams->stats.rxFrames,
                                  allStreams->stats.txFrames,
                                  allStreams->stats.rxPayloadBytes,
                                  allStreams->stats.txPayloadBytes); 
#endif
          recvStatsResp->status = STATUS_COMPLETE;
          recvStatsResp->streamId = allStreams->id;
          memcpy(&recvStatsResp->cmdru.stats, &allStreams->stats, sizeof(tgStats_t));          

          recvStatsResp++;
          total++;
      } 
      allStreams++;
   } 

#if 0
   DPRINT_INFO(WFA_OUT, "%i %i %i %i %i %i\n", first->cmdru.stats.txFrames,
                                  first->cmdru.stats.rxFrames,
                                  first->cmdru.stats.txPayloadBytes,
                                  first->cmdru.stats.rxPayloadBytes); 
#endif

   wfaEncodeTLV(WFA_TRAFFIC_AGENT_RECV_STOP_RESP_TLV, total*sizeof(dutCmdResponse_t),
                 (BYTE *)first, (BYTE *)buff);

   pkLen = WFA_TLV_HDR_LEN + total*sizeof(dutCmdResponse_t); 
#if 0
   for(i = 0; i< pkLen; i++)
   DPRINT_INFO(WFA_OUT, "%x ", buff[i]);

   DPRINT_INFO(WFA_OUT, "\n");
#endif

   if(wfaCtrlSend(sock, (BYTE *)buff, pkLen) != pkLen)
   {
       DPRINT_WARNING(WFA_WNG, "wfaCtrlSend Error\n");
   }

   DPRINT_INFOL(WFA_OUT, "wfaRecvStatsResp exit: gstream is %d\n",gStreams);
   return;
}