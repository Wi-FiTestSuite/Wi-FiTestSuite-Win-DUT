
/****************************************************************************
 *  (c) Copyright 2007 Wi-Fi Alliance.  All Rights Reserved
 *
 *  LICENSE
 *
 *  License is granted only to Wi-Fi Alliance members and designated
 *  contractors (“Authorized Licensees”).N  Authorized Licensees are granted
 *  the non-exclusive, worldwide, limited right to use, copy, import, export
 *  and distribute this software:
 *  (i) solely for noncommercial applications and solely for testing Wi-Fi
 *  equipment; and
 *  (ii) solely for the purpose of embedding the software into Authorized
 *  Licensee’s proprietary equipment and software products for distribution to
 *  its customers under a license with at least the same restrictions as
 *  contained in this License, including, without limitation, the disclaimer of
 *  warranty and limitation of liability, below.N  The distribution rights
 *  granted in clause
 *  (ii), above, include distribution to third party companies who will
 *  redistribute the Authorized Licensee’s product to their customers with or
 *  without such third party’s private label. Other than expressly granted
 *  herein, this License is not transferable or sublicensable, and it does not
 *  extend to and may not be used with non-Wi-Fi applications.N  Wi-Fi Alliance
 *  reserves all rights not expressly granted herein.N 
 *N 
 *  Except as specifically set forth above, commercial derivative works of
 *  this software or applications that use the Wi-Fi scripts generated by this
 *  software are NOT AUTHORIZED without specific prior written permission from
 *  Wi-Fi Alliance.
 *N 
 *  Non-Commercial derivative works of this software for internal use are
 *  authorized and are limited by the same restrictions; provided, however,
 *  that the Authorized Licensee shall provide Wi-Fi Alliance with a copy of
 *  such derivative works under a perpetual, payment-free license to use,
 *  modify, and distribute such derivative works for purposes of testing Wi-Fi
 *  equipment.
 *N 
 *  Neither the name of the author nor "Wi-Fi Alliance" may be used to endorse
 *  or promote products that are derived from or that use this software without
 *  specific prior written permission from Wi-Fi Alliance.
 *
 *  THIS SOFTWARE IS PROVIDED BY WI-FI ALLIANCE "AS IS" AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR AN PARTICULAR PURPOSE,
 *  ARE DISCLAIMED. IN NO EVENT SHALL WI-FI ALLIANCE BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, THE COST OF PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 *  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE) ARISING IN ANY WAY OUT OF
 *  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ******************************************************************************
 */
/*
 *    File: wfa_tg.c 
 *    Library functions for traffic generator.
 *    They are shared with both TC and DUT agent.
 * 
 *    Revision History:
 *       2008/11/12 --  Sigma Beta2 - Timer Fixed for START SYNC and TRANS profile for Windows code - [AV]
 *       2009/09/30 -- WINv03.00.00 - Simga 3.0 Release, supports TGn Program including WMM and WPA2 [QH]
 */
#include "stdafx.h"
#include <stdio.h>
#ifdef _WINDOWS
//#include <winsock.h>
#include "winsock2.h"
#include <windows.h>
#include <time.h>

#else
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <signal.h>
#include <sys/time.h>
#include <netdb.h>
#include <pthread.h>
#endif
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <math.h>

#include "wfa_debug.h"
#include "wfa_ver.h"
#include "wfa_main.h"
#include "wfa_tlv.h"
#include "wfa_tg.h"
#include "wfa_cmds.h"
#include "wfa_sock.h"
#include "wfa_rsp.h"
#include "wfa_wmmps.h"
#include "wfa_miscs.h"
#include "wfa_types.h"
#ifdef _WINDOWS
#define CLOSE closesocket
#else
#define CLOSE close
#endif
//extern tgStream_t *gStreams;
extern tgStream_t gStreams[WFA_MAX_TRAFFIC_STREAMS];
extern BOOL gtgRecv;
extern BOOL gtgSend;
extern BOOL gtgTransac;
extern int btSockfd;
extern int gtimeOut;
extern int gRegSec;
extern char gCmdStr[WFA_CMD_STR_SZ];

extern int adj_latency;

extern tgStream_t *findStreamProfile(int);
extern DWORD WINAPI wfa_traffic_resend_results_thread(void *direction);
extern int wfaTrafficSendTo(int, char *, int, struct sockaddr *);
extern int wfaTrafficRecv(int, char *, struct sockaddr *);
extern unsigned short wfa_defined_debug;
extern int tgSockfds[];
#define DONE 1
#ifdef WFA_WMM_EXT
extern tgWMM_t wmm_thr[];

extern double min_rttime;
extern double gtgPktRTDelay;
extern BOOL gtgStartSync;
extern tgE2EStats_t *e2eStats;
extern int e2eCnt;
extern int gettimeofday(struct timeval *tv, void *tz);
extern void int2BuffBigEndian(int val, char *buf);
extern int bigEndianBuff2Int(char *buff);

#ifdef WFA_WMM_PS_EXT
extern int gtgWmmPS;
extern wfaWmmPS_t wmmps_info;
extern int psSockfd;
extern unsigned int psTxMsg[];
extern unsigned int psRxMsg[];
extern int gtgPsPktRecvd;

extern void wfaSetDUTPwrMgmt(int mode);
void wmmps_wait_state_proc();

#endif

#endif


static int runLoop = 0;
static int streamId = 0;
static int totalTranPkts = 0, sentTranPkts = 0;
static int slotCnt = 0;

extern int mainSendThread;

#ifdef WFA_WMM_EXT
static int usedThread = 0;
#ifndef _WINDOWS

char e2eResults[24];
#else
char e2eResults[124];
#endif
#if 0  /* for test purpose only */
char *e2eResults = "/tmp/e2e1198798626.txt";
#endif

#endif

extern dutCmdResponse_t gGenericResp;


extern tgStream_t *theStreams;

#ifdef _WINDOWS
extern DWORD WINAPI wfa_wpa2_sleep_thread(void *thr_param);
extern int vend;
int timer_dur=0;
DWORD thr_id;
extern 	DWORD recvThr;
#endif
	
tgStream_t *findStreamProfile(int id);
/* Some devices may only support UDP ECHO and do not have ICMP level ping */
// #define WFA_PING_UDP_ECHO_ONLY     1

/* this is to stop sending packets by timer       */ 
void tmout_stop_send(int num)
{struct timeval af;
#ifdef WFA_WMM_EXT
    int i =0;
#endif
gettimeofday(&af,0);
DPRINT_INFO(WFA_OUT, "Exiting sendLongFile  at sec %d usec %d\n", af.tv_sec,af.tv_usec);
    DPRINT_INFO(WFA_OUT, "timer fired, stop sending traffic\n");

    /*
     *  After runLoop reset, all sendLong will stop
     */
    runLoop = 0;

#ifdef WFA_WMM_EXT
    /*
     * once usedThread is reset, WMM tests using multithread is ended
     * the threads will be reused for the next test.
     */
    usedThread = 0;
#endif

    /*
     * once the stream table slot count is reset, it implies that the test
     * is done. When the next set profile command comes in, it will reset/clean
     * the stream table. 
     */
    slotCnt = 0;

    /*
     * The test is for DT3 transaction test.
     * Timeout to stop it.
     */
    if(gtgTransac != 0)
    {
        gtgSend = 0;
        gtgRecv = 0;
	CLOSE(btSockfd);
	btSockfd = -1;

#ifdef WFA_WMM_EXT
        /* Voice End 2 End Sync */
	min_rttime = 0xFFFFFFFF;
	if(gtgStartSync != 0)
	{
	  gtgStartSync = 0;
	  printf("stopping StartSync\n");
	}
#endif
    }

#ifdef WFA_WMM_EXT
    /*
     * all WMM streams also stop
     */ 		
    for(i=0; i<WFA_TRAFFIC_CLASS_NUM; i++)
    {
       	wmm_thr[i].thr_flag = 0; 		
    }
#endif
#ifdef resolve
    /* all alarms need to reset */
    alarm(0);
#endif
}

/*
 * findStreamProfile(): search existing stream profile by stream id
 * input: id - stream id;
 * return: matched stream profile
 */

tgStream_t *findStreamProfile(int id)
{
    volatile int i;
    tgStream_t *myStream = gStreams;

    for(i = 0; i< WFA_MAX_WMM_STREAMS; i++)
    {
       if(myStream->id == id)
          return myStream;
       
       myStream++;
    }

    return NULL;
}

/*
 * wfaTGSendPing(): Instruct Traffic Generator to send ping packets
 *
 */
int wfaTGSendPing(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    int totalpkts;
    char cmdStr[128];
    int streamid = ++streamId;
    int interval;      /* it in milli second */ 
    tgPingStart_t *staPing = (tgPingStart_t *)caCmdBuf;
    dutCmdResponse_t *spresp = &gGenericResp;

#ifdef WFA_PING_UDP_ECHO_ONLY
    tgStream_t *myStream = NULL;
#endif

    DPRINT_INFO(WFA_OUT, "Entering wfaTSendPing ...\n");
    if(staPing->frameSize == 0)
         staPing->frameSize = 100;

    if(staPing->frameRate == 0)
         staPing->frameRate = 1;

    interval = (int)((1/staPing->frameRate)*1000);

    if(staPing->duration == 0)
         staPing->duration = 10;

    switch(staPing->type)
    {
    case WFA_PING_ICMP_ECHO:
#ifndef WFA_PING_UDP_ECHO_ONLY
        totalpkts = staPing->duration * staPing->frameRate;

#if !defined(_CYGWIN) && !defined(_WINDOWS)
        sprintf(cmdStr, "echo streamid=%i > /tmp/spout.txt; /bin/ping %s -i %f -c %i -s %i -q >> /tmp/spout.txt 2>/dev/null&",
          streamid, staPing->dipaddr, interval, totalpkts, staPing->frameSize); 
#else
#ifdef _CYGWIN
        sprintf(cmdStr, "echo streamid=%i > /tmp/spout.txt; /bin/ping %s  %d   %d >> /tmp/spout.txt 2>/dev/null&",
          streamid, staPing->dipaddr,  staPing->frameSize,totalpkts); 
#else
		//sprintf(cmdStr, "echo streamid=%i > c:\\windows\\temp\\spout.txt",streamid);
		//printf("Executing %s\n",cmdStr);
        //system(cmdStr);
		sprintf(cmdStr, "del /F c:\\WFA\\spout.txt");
		system(cmdStr);

		//if(staPing->frameRate > 1)
//		sprintf(cmdStr, "start \"MPING\" cmd /C \"win7ping %s  -l %d  -c %d -i %d -w %d -f  c:\\WFA\\spout.txt\"",
//			staPing->dipaddr,  staPing->frameSize,totalpkts,(int)(interval*1000*0.9),(int)(interval*1000*0.1));

		sprintf(cmdStr, "start \"MPING\" cmd /C \"myping %s  -l %d -i %d -n %d -f  c:\\WFA\\spout.txt\"",
			staPing->dipaddr,  staPing->frameSize,interval,totalpkts);
		//else
		//sprintf(cmdStr, "start \"MPING\" cmd /C \"myping  %s  -l %d  -n %d -f  c:\\WFA\\spout.txt\"",
		//	staPing->dipaddr,  staPing->frameSize,totalpkts);

//		sprintf(cmdStr, "start \"MPING\" cmd /C \"win7ping %s  -l %d  -c %d -i %d -w %d -f  c:\\WFA\\spout.txt\"",
	//		staPing->dipaddr,  staPing->frameSize,totalpkts,1000,500);

#endif
#endif
   printf("Executing %s\n",cmdStr);
        system(cmdStr);

        spresp->status = STATUS_COMPLETE;
        spresp->streamId = streamid;
#elif
        printf("Only support UDP ECHO\n");
#endif
        break;

    case WFA_PING_UDP_ECHO:
    {
#ifdef WFA_PING_UDP_ECHO_ONLY
        /*
         * Make this like a transaction testing
         * Then make it a profile and run it    
         */
        myStream = &gStreams[slotCnt++];
        memset(myStream, 0, sizeof(tgStream_t));
        memcpy(&myStream->profile, caCmdBuf, len);
        myStream->id = streamid; /* the id start from 1 */ 
        myStream->tblidx = slotCnt-1; 

        btSockfd = wfaCreateUDPSock("127.0.0.1", WFA_UDP_ECHO_PORT);
        if((btSockfd = wfaConnectUDPPeer(btSockfd, staPing->dipaddr, WFA_UDP_ECHO_PORT)) > 0)
        {
            gtgTransac = streamid;        
            gtgSend = streamid;
            totalTranPkts = 512;
            sentTranPkts = 0;

            /*
             * the framerate here is used to derive the timeout 
             * value for waiting transaction echo responses.
             */
            gtimeOut = MINISECONDS/staPing->frameRate;  /* in msec */

            /* set to longest time */
            if(staPing->duration == 0)
                staPing->duration = 3600;
        }
#else
        printf("Doesn't support UDP Echo\n");
#endif
        break;
    }
    default:
    {
        spresp->status = STATUS_INVALID;
        spresp->streamId = streamid;
    }
    }
        
    
    wfaEncodeTLV(WFA_TRAFFIC_SEND_PING_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)spresp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

    return TRUE;
}

/*
 * tgStopPing(): Instruct Traffic Generator to stop ping packets
 *
 */
int wfaTGStopPing(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    int streamid = (int )*(caCmdBuf+4); 
    dutCmdResponse_t *stpResp = &gGenericResp;
    char strout[256];
	char _strout[256];
    FILE *tmpfile = NULL;
    tgStream_t *myStream;

	printf("Entering StopPing ...");
    stpResp->status = STATUS_COMPLETE;
	/*
    if( gtgTransac == streamid&&gtgSend == streamid)
    {
		printf("\nInside IF gtgTrans  ...\n");
        gtgTransac =0;
        gtgSend = 0;
        gtimeOut = 0;
        gtgRecv = 0;
#ifdef resolve
        alarm(0);
#endif

        myStream = findStreamProfile(streamid); 
        if(myStream == NULL)
        {
            stpResp->status = STATUS_INVALID;
        }

        stpResp->cmdru.pingStp.sendCnt = myStream->stats.txFrames;
        stpResp->cmdru.pingStp.repliedCnt = myStream->stats.rxFrames;
        
    }
	*/
//    else
    {
#ifndef _WINDOWS
        system("stoping.sh; sleep 2");

        system("getpstats.sh /tmp/spout.txt");

        tmpfile = fopen("/tmp/stpsta.txt", "r+");

        if(tmpfile == NULL)
        {
            stpResp->status = STATUS_COMPLETE;

            wfaEncodeTLV(WFA_TRAFFIC_STOP_PING_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)stpResp, respBuf);
            *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

            return FALSE;
        }

        if(fscanf(tmpfile, "%s", strout) != EOF)
        {
            if(*strout == '\0')
            {
                stpResp->cmdru.pingStp.sendCnt = 0;
            }
            else
                stpResp->cmdru.pingStp.sendCnt = atoi(strout);
        }
    
        if(fscanf(tmpfile, "%s", strout) != EOF)
        {
            if(*strout == '\0')
            {
                stpResp->cmdru.pingStp.repliedCnt = 0;
            }
            else
                stpResp->cmdru.pingStp.repliedCnt = atoi(strout);
        }
#else
		// sent 4 received 4 - format of myping output
		char *str;
		printf("\nEntering Windows 7 Ping ...\n");

		//system("taskkill /IM win7ping.exe /F");

		system("taskkill /IM myping.exe /F");
		//sprintf(gCmdStr,"del /F c:\\WFA\\ping.txt");
		//system(gCmdStr);

		//Sleep(3000);
		//sprintf(gCmdStr, "FOR /F \"tokens=4,7 delims=, \" %s in ('findstr \"Packets\" c:\\WFA\\spout.txt') do @echo sent %s recieved %s > c:\\WFA\\ping.txt","%i","%i","%j");

		//printf("Executing %s\n",gCmdStr);
        //system(gCmdStr);

		//tmpfile = fopen("c:\\WFA\\ping.txt", "r+");
		tmpfile = fopen("c:\\WFA\\spout.txt", "r+");

       	if(tmpfile!=NULL)
		{
			while (fgets(_strout, 100, tmpfile) != NULL ) {
				strcpy(strout,_strout);
			}

				str = strtok(strout, " ");
				while(str && ((strcmp(str,"sent")) != 0))
				{
					str = strtok(NULL, " ");
				}
				str = strtok(NULL, " ");
				if(str)
					stpResp->cmdru.pingStp.sendCnt = atoi(str);
				else
					stpResp->cmdru.pingStp.sendCnt = 0;
				while(str && ((strcmp(str,"recieved")) != 0))
				{
					str = strtok(NULL, " ");
				}
				str = strtok(NULL, " ");
				if(str)
					stpResp->cmdru.pingStp.repliedCnt = atoi(str);
				else
					stpResp->cmdru.pingStp.repliedCnt = 0;			
		}
#endif
     }

     if(tmpfile == NULL)
     {
		 	printf("\ninside tmpfile NULL ...\n");
            stpResp->status = STATUS_COMPLETE;

            wfaEncodeTLV(WFA_TRAFFIC_STOP_PING_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)stpResp, respBuf);
            *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

            return FALSE;
     }
     else
     {
		 fclose(tmpfile);
         wfaEncodeTLV(WFA_TRAFFIC_STOP_PING_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)stpResp, respBuf);
         *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
     }
     //fclose(tmpfile);
     return TRUE;
}

/*
 * wfaTGConfig: store the traffic profile setting that will be used to
 *           instruct traffic generation.
 * input: cmd -- not used
 * response: send success back to controller
 * return: success or fail
 * Note: the profile storage is a global space.
 */
int wfaTGConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    int ret = FALSE;
    tgStream_t *myStream = NULL;
    dutCmdResponse_t *confResp = &gGenericResp;
    
    /* if the stream table over maximum, reset it */ 
    if(slotCnt == WFA_MAX_TRAFFIC_STREAMS)
       slotCnt = 0;

    if(slotCnt == 0)
    {
       printf("resetting stream table for %d\n",gStreams);
       memset(gStreams, 0, WFA_MAX_TRAFFIC_STREAMS*sizeof(tgStream_t));
    }
   
    DPRINT_INFO(WFA_OUT, "entering tcConfig ...\n");
    myStream = &gStreams[slotCnt++];
    memset(myStream, 0, sizeof(tgStream_t));
    memcpy(&myStream->profile, caCmdBuf, len);
    myStream->id = ++streamId; /* the id start from 1 */ 
    myStream->tblidx = slotCnt-1;

#if 1
    DPRINT_INFO(WFA_OUT, "profile %i direction %i dest ip %s dport %i source %s sport %i rate %i duration %i size %i class %i delay %i\n", myStream->profile.profile, myStream->profile.direction, myStream->profile.dipaddr, myStream->profile.dport, myStream->profile.sipaddr, myStream->profile.sport, myStream->profile.rate, myStream->profile.duration, myStream->profile.pksize, myStream->profile.trafficClass, myStream->profile.startdelay);
#endif
 
    confResp->status = STATUS_COMPLETE; 
    confResp->streamId = myStream->id;
    wfaEncodeTLV(WFA_TRAFFIC_AGENT_CONFIG_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)confResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t); 

    
    return ret;
}

HANDLE recv_mutex;
/*
 * wfaTGRecvStart: instruct traffic generator to start receiving 
 *                 based on a profile
 * input:      cmd -- not used
 * response:   inform controller for "running"
 * return:     success or failed 
 */
int wfaTGRecvStart(int len, BYTE *parms, int *respLen, BYTE *respBuf)
{
    int status = STATUS_COMPLETE, i;
    int numStreams = len/4;
    int streamid, so;
    tgProfile_t *theProfile;
    tgStream_t *myStream;
	int thisSockfd = -1;
#ifdef _WINDOWS
    int iOptVal;
    int iOptLen = sizeof(int);
#endif


    DPRINT_INFO(WFA_OUT, "entering tgRecvStart\n");

    /*
     * The function wfaSetProcPriority called here is to enhance the real-time
     * performance for packet receiving. It is only for tuning and optional
     * to implement
     */
    //wfaSetProcPriority(60);

    for(i=0; i<numStreams; i++)
    {
        memcpy(&streamid, parms+(4*i), 4); /* changed from 2 to 4, bug reported by n.ojanen */
        myStream = findStreamProfile(streamid); 
        if(myStream == NULL)
        {
            status = STATUS_INVALID;
            return status;    
        }

        theProfile = &myStream->profile;
        if(theProfile == NULL)
        {
           status = STATUS_INVALID;
           return status;
        }

        /* calculate the frame interval which is used to derive its jitter */
        if(theProfile->rate != 0 && theProfile->rate < 5000)
           myStream->fmInterval = 1000000/theProfile->rate; /* in ms */
        else
           myStream->fmInterval = 0;

        if(theProfile->direction != DIRECT_RECV)
        {
           status = STATUS_INVALID;
           return status;
        }

        memset(&myStream->stats, 0, sizeof(tgStats_t));

        // mark the stream active
        myStream->state = WFA_STREAM_ACTIVE;
       
        switch(theProfile->profile)
        {
#if 0
            case PROF_FILE_TX:
            status = STATUS_COMPLETE;
            thisSockfd = btSockfd = wfaCreateUDPSock(theProfile->dipaddr, theProfile->dport);

            if(btSockfd >= 0)
			{
               gtgRecv = streamid;
			}
            else
               status = STATUS_ERROR;

            break;
#endif

            case PROF_MCAST:
            status = STATUS_COMPLETE;
            thisSockfd = btSockfd = wfaCreateUDPSock(theProfile->dipaddr, theProfile->dport);
            if(btSockfd >= 0)
            {
                gtgRecv = streamid;
            }
            else
            {
                status = STATUS_ERROR;
                wfaEncodeTLV(WFA_TRAFFIC_AGENT_RECV_START_RESP_TLV, 4, (BYTE *)&status, respBuf);
                *respLen = WFA_TLV_HDR_LEN + 4;

                return TRUE;
                break;
            }

            /* set multicast socket option for receiver */
            so = wfaSetSockMcastRecvOpt(btSockfd, theProfile->dipaddr);
            if(so < 0)
            {
				perror("set mcastat: ");
                DPRINT_ERR(WFA_ERR, "setsockopt at %: ", theProfile->dipaddr);
                CLOSE(btSockfd);
                gtgRecv = 0;
                status = STATUS_ERROR;
                wfaEncodeTLV(WFA_TRAFFIC_AGENT_RECV_START_RESP_TLV, 4, (BYTE *)&status, respBuf);
                *respLen = WFA_TLV_HDR_LEN + 4;

                return TRUE;
            }
         break;

         case PROF_FILE_TX:
         case PROF_IPTV:
#ifdef WFA_WMM_EXT
            /*
             * singal the thread to Sending WMM traffic 
             */
         
            wmm_thr[usedThread].thr_flag = streamid;

#ifdef _WINDOWS
			printf("usedThread %i\n", usedThread);
            printf("\r\nFired thread %d\n",usedThread);
		    printf("\r\nThread %d flag is %d\n",usedThread,wmm_thr[usedThread].thr_flag);
            ReleaseMutex(wmm_thr[usedThread].thr_flag_mutex);
            Sleep(10);
			ReleaseMutex(wmm_thr[usedThread].thr_flag_mutex);
#else
            pthread_mutex_lock(&wmm_thr[usedThread].thr_flag_mutex);
            pthread_cond_signal(&wmm_thr[usedThread].thr_flag_cond);
            pthread_mutex_unlock(&wmm_thr[usedThread].thr_flag_mutex;
#endif
		    
            usedThread++;
#endif

#if 0
#ifdef WFA_WMM_EXT
         printf("Recv start stream id %i port %i\n", streamid, theProfile->dport); 
         status = STATUS_COMPLETE;
         thisSockfd = tgSockfds[myStream->tblidx] = wfaCreateUDPSock(theProfile->dipaddr, theProfile->dport);

         if(thisSockfd >= 0)
               gtgRecv = streamid;
            else
               status = STATUS_ERROR;
#else
         DPRINT_ERR(WFA_ERR, "Incorrect profile, not supported, may need recompile\n");
                status = STATUS_ERROR;
#endif
#endif
        break;

        case PROF_TRANSC:
        case PROF_START_SYNC:
            status = STATUS_COMPLETE;
            thisSockfd = btSockfd = wfaCreateUDPSock(theProfile->sipaddr, theProfile->sport);  
            totalTranPkts = 0xFFFFFFF0;
            sentTranPkts = 0;
            if(btSockfd > 0)
            {
               gtgTransac = streamid;        
               gtgRecv = streamid;
	    }
            else
               status = STATUS_ERROR;

       break;
       
       case PROF_UAPSD:
#ifdef WFA_WMM_EXT
#ifdef WFA_WMM_PS_EXT
       status = STATUS_COMPLETE;
         psSockfd = wfaCreateUDPSock(theProfile->dipaddr, WFA_WMMPS_UDP_PORT);

         wmmps_info.sta_state = 0;
         wmmps_info.wait_state = WFA_WAIT_STAUT_00;

         memset(&wmmps_info.psToAddr, 0, sizeof(wmmps_info.psToAddr));
         wmmps_info.psToAddr.sin_family = AF_INET;
         wmmps_info.psToAddr.sin_addr.s_addr = inet_addr(theProfile->sipaddr);
         wmmps_info.psToAddr.sin_port = htons(theProfile->sport);
	 wmmps_info.reset = 0;

         wmm_thr[usedThread].thr_flag = streamid;
         wmmps_info.streamid = streamid;
         pthread_mutex_lock(&wmm_thr[usedThread].thr_flag_mutex);
         pthread_cond_signal(&wmm_thr[usedThread].thr_flag_cond);
         gtgWmmPS = streamid;;
         pthread_mutex_unlock(&wmm_thr[usedThread].thr_flag_mutex);
         usedThread++;

         gtimeOut = MINISECONDS/10;  /* in msec */
         gRegSec = 0;
#endif   /* WFA_WMM_PS_EXT */
#endif   /* WFA_WMM_EXT */
         break;
       }
    }

#ifdef _WINDOWS
	if(thisSockfd >=0)
	{
        if (getsockopt(thisSockfd, SOL_SOCKET, SO_RCVBUF, (char*)&iOptVal, &iOptLen) != SOCKET_ERROR) 
	    {
            printf("Default SO_RECVBUF Value: %ld\n", iOptVal);
        }

        iOptVal = iOptVal*20;

	    setsockopt(thisSockfd, SOL_SOCKET, SO_RCVBUF, (char*)&iOptVal, iOptLen);

        if (getsockopt(thisSockfd, SOL_SOCKET, SO_RCVBUF, (char*)&iOptVal, &iOptLen) != SOCKET_ERROR) 
	    {
           printf("New SO_RECVBUF Value: %ld\n", iOptVal);
        }
//       SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);
        SetThreadPriority((HANDLE)recvThr, THREAD_PRIORITY_ABOVE_NORMAL);
        ReleaseMutex(recv_mutex);
	}

    //ReleaseMutex(recv_mutex);
	//printf("FILE_TX release mutex\n");
#endif
    /* encode a TLV for response for "complete/error ..." */
    wfaEncodeTLV(WFA_TRAFFIC_AGENT_RECV_START_RESP_TLV, sizeof(int), 
                 (BYTE *)&status, respBuf);
    *respLen = WFA_TLV_HDR_LEN + sizeof(int); 

    return TRUE;
}

/*
 * tgRecvStop: instruct traffic generator to stop receiving based on a profile
 * input:      cmd -- not used
 * response:   inform controller for "complete"
 * return:     success or failed 
 */
int wfaTGRecvStop(int len, BYTE *parms, int *respLen, BYTE *respBuf)
{
    int status = STATUS_COMPLETE, i;
    int numStreams = len/4;
    int streamid;
    tgProfile_t *theProfile;
    tgStream_t *myStream=NULL;
    dutCmdResponse_t statResp;
    BYTE dutRspBuf[WFA_BUFF_1K];
    int id_cnt = 0;
	DWORD thr_id;
#ifdef WFA_WMM_EXT
    FILE *e2eoutp = NULL;
    struct timeval currtime;
    int j;
	int rdirect = DIRECT_RECV;
#endif

    DPRINT_INFO(WFA_OUT, "entering tgRecvStop with length %d\n",len);

    /*
     * After finishing the receiving command, it should lower itself back to 
     * normal level. It is optional implementation if it is not called 
     * while it starts receiving for raising priority level.
     */
    //wfaSetProcPriority(30);
    memset(dutRspBuf, 0, WFA_BUFF_1K);


    for(i=0; i<numStreams; i++)
    {
        memcpy(&streamid, parms+(4*i), 4);
        myStream = findStreamProfile(streamid); 
        if(myStream == NULL)
        {
            status = STATUS_INVALID;
            wfaEncodeTLV(WFA_TRAFFIC_AGENT_RECV_STOP_RESP_TLV, 4, (BYTE *)&status, respBuf);
            *respLen = WFA_TLV_HDR_LEN + 4;
            return TRUE;    
        }

        theProfile = &myStream->profile;
        if(theProfile == NULL)
        {
           status = STATUS_INVALID;
           wfaEncodeTLV(WFA_TRAFFIC_AGENT_RECV_STOP_RESP_TLV, 4, (BYTE *)&status, respBuf);
           *respLen = WFA_TLV_HDR_LEN + 4;

           return TRUE;
        }

        if(theProfile->direction != DIRECT_RECV)
        {
           status = STATUS_INVALID;
           wfaEncodeTLV(WFA_TRAFFIC_AGENT_RECV_STOP_RESP_TLV, 4, (BYTE *)&status, respBuf);
           *respLen = WFA_TLV_HDR_LEN + 4;

           return TRUE;
        }

        /* reset its flags , close sockets */
        switch(theProfile->profile)
        {
#if 0
         case PROF_FILE_TX:
            gtgRecv = 0;
            //CLOSE(btSockfd);
            //btSockfd = -1;
         break;

         case PROF_MCAST:
            gtgRecv = 0;
            //CLOSE(btSockfd);
            //btSockfd = -1;
         break;
#endif
		 case PROF_FILE_TX:
		 case PROF_MCAST:
         case PROF_IPTV:
         printf("rec stop %i\n",  streamid);
         WaitForSingleObject( recv_mutex, 50 );
         //WaitForSingleObject( recv_mutex);
	     printf("acquired mutex after stop\n");
		 Sleep(20);
         gtgRecv = 0;
#ifdef WFA_WMM_EXT
         printf("rec stop %i\n",  streamid);
         CLOSE(tgSockfds[myStream->tblidx]);
         tgSockfds[myStream->tblidx] = -1;

#if 0
	     /* the following to report the result.
	      * the upload command will send the records back to TM
	      */
	     gettimeofday(&currtime, NULL);

#ifndef _WINDOWS
	     sprintf(e2eResults, "/tmp/e2e%u.txt", (unsigned int) currtime.tv_sec); 
#else
	     sprintf(e2eResults, "c:\\windows\\temp\\e2e%u.txt", (unsigned int) currtime.tv_sec); 
#endif
	     e2eoutp = fopen(e2eResults, "w+");
         if(e2eoutp != NULL)
         {
	         printf("e2eCnt %i filename %s lost pkts %i\n", e2eCnt, e2eResults,myStream->stats.lostPkts);
	         fprintf(e2eoutp, "roundtrip delay: %i\n", (int) (1000000*gtgPktRTDelay)); 
	         for(j = 0; j< e2eCnt; j++)
             {
                 fprintf(e2eoutp, "%i:%i:%i:%i:%i\n", e2eStats[j].seqnum, e2eStats[j].lsec, e2eStats[j].lusec, e2eStats[j].rsec, e2eStats[j].rusec);
	     }
             fclose(e2eoutp);
         }
         else
         {
             DPRINT_ERR(WFA_ERR, "Failed to open file to store test records.");
         }

         e2eCnt = 0;
         memset(e2eStats, 0, 6000*sizeof(tgE2EStats_t));
#endif
#endif
         break;

         case PROF_TRANSC:
         case PROF_START_SYNC:
            gtgTransac = 0;        
            gtgRecv = 0;
            CLOSE(btSockfd);
            btSockfd = -1;
         break;
	 case PROF_UAPSD:
#ifdef WFA_WMM_EXT
#ifdef WFA_WMM_PS_EXT
         gtgWmmPS = 0;
         gtgPsPktRecvd = 0;

         if(psSockfd != -1)
         {
             CLOSE(psSockfd);
             psSockfd = -1;
         }

         memset(&wmmps_info, 0, sizeof(wfaWmmPS_t));

         wfaSetDUTPwrMgmt(PS_OFF);
#endif
#endif
         break;

         }
//         SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
         SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
        
    	/* encode a TLV for response for "complete/error ..." */
    	statResp.status = STATUS_COMPLETE; 
    	statResp.streamId = streamid; 

#if 1
    	DPRINT_INFO(WFA_OUT, "stream Id %i rx %lu total %llu\n", streamid, myStream->stats.rxFrames, myStream->stats.rxPayloadBytes);
#endif
    	memcpy(&statResp.cmdru.stats, &myStream->stats, sizeof(tgStats_t));
     	memcpy((dutRspBuf + i * sizeof(dutCmdResponse_t)), (BYTE *)&statResp, sizeof(dutCmdResponse_t));
	id_cnt++;
		printf("Size of a stream is %d\n",sizeof(tgStream_t));
      // Not empty it but require to reset the entire table before test starts.
        //memset(myStream, 0, sizeof(tgStream_t));
    }

//    WaitForSingleObject( recv_mutex, INFINITE );
//	printf("acquired mutex after stop\n");

    // mark the stream inactive
    myStream->state = WFA_STREAM_INACTIVE;

    wfaEncodeTLV(WFA_TRAFFIC_AGENT_RECV_STOP_RESP_TLV, id_cnt * (int) sizeof(dutCmdResponse_t), 			dutRspBuf, respBuf);

    /* done here */
    *respLen = WFA_TLV_HDR_LEN + numStreams * sizeof(dutCmdResponse_t); 

    //CreateThread(NULL, 0, wfa_traffic_resend_results_thread, (PVOID)&rdirect, 0, &thr_id);

    return TRUE;
}

/*
 * wfaTGSendStart: instruct traffic generator to start sending based on a profile
 * input:      cmd -- not used
 * response:   inform controller for "running"
 * return:     success or failed 
 */
int wfaTGSendStart(int len, BYTE *parms, int *respLen, BYTE *respBuf)
{
    int i=0, streamid=0, so;
    int numStreams = len/4;

    tgProfile_t *theProfile;
    tgStream_t *myStream = NULL;
#ifdef _WINDOWS
    int iOptVal;
    int iOptLen = sizeof(int);
#endif

#ifdef WFA_WMM_EXT
//    struct timeval btime;
#endif
    dutCmdResponse_t staSendResp;

    DPRINT_INFO(WFA_OUT, "Entering tgSendStart for %i streams ...\n", numStreams);
    for(i=0; i<numStreams; i++)
    {
        memcpy(&streamid, parms+(4*i), 4);
		printf("streamid to look for is %d\n",streamid);
        myStream = findStreamProfile(streamid); 
        if(myStream == NULL)
        {
           staSendResp.status = STATUS_INVALID;
           wfaEncodeTLV(WFA_TRAFFIC_AGENT_SEND_RESP_TLV, 4, (BYTE *)&staSendResp, respBuf);
           *respLen = WFA_TLV_HDR_LEN + 4;
           return TRUE;
        }

        theProfile = &myStream->profile;
        if(theProfile == NULL)
        {
           staSendResp.status = STATUS_INVALID;
           wfaEncodeTLV(WFA_TRAFFIC_AGENT_SEND_RESP_TLV, 4, (BYTE *)&staSendResp, respBuf);
           *respLen = WFA_TLV_HDR_LEN + 4;

           return TRUE;
        }
               
        if(theProfile->direction != DIRECT_SEND)
        {
           staSendResp.status = STATUS_INVALID;
           wfaEncodeTLV(WFA_TRAFFIC_AGENT_SEND_RESP_TLV, 4, (BYTE *)&staSendResp, respBuf);
           *respLen = WFA_TLV_HDR_LEN + 4;

           return TRUE;
        }

        /*
         * need to reset the stats
         */
        memset(&myStream->stats, 0, sizeof(tgStats_t));

        // mark the stream active;
        myStream->state = WFA_STREAM_ACTIVE;

        switch(theProfile->profile)
        {
           case PROF_FILE_TX:
           btSockfd = wfaCreateUDPSock(theProfile->sipaddr, theProfile->sport);
           if((btSockfd=wfaConnectUDPPeer(btSockfd, theProfile->dipaddr, theProfile->dport)) > 0)
           {
               gtgSend = streamid;
           }
           else
           {
               staSendResp.status = STATUS_ERROR;
               wfaEncodeTLV(WFA_TRAFFIC_AGENT_SEND_RESP_TLV, 4, (BYTE *)&staSendResp, respBuf);
               *respLen = WFA_TLV_HDR_LEN + 4;

               return TRUE;
           }
           //wfaSetProcPriority(60);
           break;

           case PROF_MCAST:
           btSockfd = wfaCreateUDPSock(theProfile->sipaddr, theProfile->sport);
           if(btSockfd)
           {
               gtgSend = streamid;
           }
           else
           {
               staSendResp.status = STATUS_ERROR;

               wfaEncodeTLV(WFA_TRAFFIC_AGENT_SEND_RESP_TLV, 4, (BYTE *)&staSendResp, respBuf);
               *respLen = WFA_TLV_HDR_LEN + 4;

               return TRUE;
           }

           so = wfaSetSockMcastSendOpt(btSockfd);
           if (so < 0)
           {
               DPRINT_ERR(WFA_ERR, "setsockopt for mcast: ");
               gtgSend = 0;
               CLOSE(btSockfd);
               btSockfd = -1;
               staSendResp.status = STATUS_ERROR;

               wfaEncodeTLV(WFA_TRAFFIC_AGENT_SEND_RESP_TLV, 4, (BYTE *)&staSendResp, respBuf);
               *respLen = WFA_TLV_HDR_LEN + 4;

                return TRUE;
            }
            //wfaSetProcPriority(60)
            break;
            case PROF_IPTV:
#ifdef WFA_WMM_EXT
            /*
             * singal the thread to Sending WMM traffic 
             */
         
            wmm_thr[usedThread].thr_flag = streamid;
			mainSendThread = usedThread;

#ifdef _WINDOWS
			printf("usedThread %i\n", usedThread);
            printf("\r\nFired thread %d\n",usedThread);
		    printf("\r\nThread %d flag is %d\n",usedThread,wmm_thr[usedThread].thr_flag);
            ReleaseMutex(wmm_thr[usedThread].thr_flag_mutex);
            Sleep(10);
			ReleaseMutex(wmm_thr[usedThread].thr_flag_mutex);
#else
            pthread_mutex_lock(&wmm_thr[usedThread].thr_flag_mutex);
            pthread_cond_signal(&wmm_thr[usedThread].thr_flag_cond);
            pthread_mutex_unlock(&wmm_thr[usedThread].thr_flag_mutex
#endif
		    
            usedThread++;
            //wfaSetProcPriority(90);
            //SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);

#endif
            break;

            case PROF_TRANSC:
            {
               btSockfd = wfaCreateUDPSock(theProfile->sipaddr, theProfile->sport);
               if((btSockfd = wfaConnectUDPPeer(btSockfd, theProfile->dipaddr, theProfile->dport)) > 0)
               {
                   gtgTransac = streamid;        
                   gtgSend = streamid;
                   totalTranPkts = theProfile->rate * theProfile->duration;
                   sentTranPkts = 0;

                   /*
                    * the framerate here is used to derive the timeout 
                    * value for waiting transaction echo responses.
                    */
                   gtimeOut = MINISECONDS/theProfile->rate;  /* in msec */
               }
               else
               {
                   staSendResp.status = STATUS_ERROR;
                   wfaEncodeTLV(WFA_TRAFFIC_AGENT_SEND_RESP_TLV, 4, (BYTE *)&staSendResp, respBuf);
                   *respLen = WFA_TLV_HDR_LEN + 4;

                   return TRUE;
               }

               /* set duration for the test */
#ifndef _WINDOWS
               signal(SIGALRM, tmout_stop_send);
               alarm(theProfile->duration);
#else
		    //   SetTimer(0, 0, (theProfile->duration)*1000, (TIMERPROC)tmout_stop_send);
		       printf("\r\n TRANSFIX -Setting timer for %d ms\n",(theProfile->duration)*1000);
		       timer_dur = (theProfile->duration)*1000;
		       CreateThread(NULL, 0, wfa_wpa2_sleep_thread, (PVOID)&timer_dur, 0,&thr_id);
#endif
            }
            break;
#ifdef WFA_WMM_EXT
            case PROF_START_SYNC:
            {
	           printf("profile port %i\n", theProfile->sport);
               btSockfd = wfaCreateUDPSock(theProfile->sipaddr, theProfile->sport);
               if((btSockfd = wfaConnectUDPPeer(btSockfd, theProfile->dipaddr, theProfile->dport)) > 0)
               {
                   gtgTransac = streamid;        
                   gtgSend = streamid;
                   totalTranPkts = theProfile->rate * theProfile->duration;
                   sentTranPkts = 0;
	               if(theProfile->profile == PROF_START_SYNC)
	                  gtgStartSync = streamid;

                   /*
                    * the framerate here is used to derive the timeout 
                    * value for waiting transaction echo responses.
                    */
                   gtimeOut = MINISECONDS/theProfile->rate;  /* in msec */
               }
	           else
	           {
	               printf("connection failed\n");
	           }
 
               /* set duration for the test */
#ifndef _WINDOWS
               signal(SIGALRM, tmout_stop_send);
               alarm(theProfile->duration+1);
#else
	           // SetTimer(0, 0, (theProfile->duration +1)*1000, (TIMERPROC)tmout_stop_send);
               printf("\r\n SYNCFIX -Setting timer for %d ms\n",(theProfile->duration)*1000);
	           timer_dur = (theProfile->duration)*1000;
	           CreateThread(NULL, 0, wfa_wpa2_sleep_thread, (PVOID)&timer_dur, 0,&thr_id);

#endif
            }
	        break;
#endif
	     } // switch
#ifdef _WINDOWS
         if(btSockfd != -1)
	     {
             if (getsockopt(btSockfd, SOL_SOCKET, SO_SNDBUF, (char*)&iOptVal, &iOptLen) != SOCKET_ERROR) 
	         {
                  printf("SO_SNDBUF Value: %ld\n", iOptVal);
             }

	         iOptVal = iOptVal*40;
			 //iOptVal = 262120;

	         setsockopt(btSockfd, SOL_SOCKET, SO_SNDBUF, (char*)&iOptVal, iOptLen);

             if (getsockopt(btSockfd, SOL_SOCKET, SO_SNDBUF, (char*)&iOptVal, &iOptLen) != SOCKET_ERROR) 
		     {
                printf("SO_SNDBUF Value: %ld\n", iOptVal);
             }
	      }
#endif
    } // for

    *respLen = 0;
    return TRUE;
}

int wfaTGReset(int len, BYTE *parms, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *resetResp = &gGenericResp;
	int i;
DPRINT_INFO(WFA_OUT, "Entering tgreset for btsok %d ...\n",btSockfd);
    /* need to reset all traffic socket fds */
//    SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
    if(btSockfd != -1)
    {
       CLOSE(btSockfd);
       btSockfd = -1;
    }
	for(i=0;i<WFA_MAX_TRAFFIC_STREAMS;i++)
		if(tgSockfds[i] > 0)
		{
			printf("Warning,Closing a socket which should have been closed earlier\n");
			CLOSE(tgSockfds[i]);
			tgSockfds[i] = -1;
		}

#ifdef resolve
    /* reset the timer alarm if it was armed */
    alarm(0);
#endif
    /* just reset the flags for the command */
    gtgRecv = 0;
    gtgSend = 0;
    gtgTransac = 0;
    totalTranPkts = 0;
    gtimeOut = 0;

    runLoop = 0;

#ifdef WFA_WMM_EXT
    usedThread = 0;
#ifdef WFA_WMM_PS_EXT
	 gtgWmmPS = 0;
	 gtgPsPktRecvd = 0;

	 if(psSockfd != -1)
	 {
             close(psSockfd);
             psSockfd = -1;
	 }

         memset(&wmmps_info, 0, sizeof(wfaWmmPS_t));

         wfaSetDUTPwrMgmt(PS_OFF);
#endif
		   DPRINT_INFO(WFA_OUT, "before memset...\n");
    gtgStartSync = 0;
    e2eCnt = 0;
    e2eResults[0] = '\0';
    memset(e2eStats, 0, 6000*sizeof(tgE2EStats_t));
#endif
//DPRINT_INFO(WFA_OUT, "after memset...\n");
    /* Also need to clean up WMM streams NOT DONE YET!*/
    slotCnt = 0;             /* reset stream profile container */
	memset(gStreams, 0, WFA_MAX_TRAFFIC_STREAMS*sizeof(tgStream_t));
  //  memset(gStreams, 0, WFA_MAX_TRAFFIC_STREAMS-1); 
DPRINT_INFO(WFA_OUT, "after memset streams...\n");
//fflush(stdout);
    /*
     * After be asked to reset, it should lower itself back to 
     * normal level. It is optional implementation if it is not called 
     * while it starts sending/receiving for raising priority level.
     */
    //wfaSetProcPriority(20);

    /* encode a TLV for response for "complete ..." */
    resetResp->status = STATUS_COMPLETE; 
    wfaEncodeTLV(WFA_TRAFFIC_AGENT_RESET_RESP_TLV, 4, 
                 (BYTE *)resetResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4; 
DPRINT_INFO(WFA_OUT, "Exiting tgreset for ...\n");
    return TRUE;
}

/*
 * calculate the sleep time for different frame rate
 * It should be done according the device
 * This is just one way to adjust the packet delivery speed. If you find 
 * you device does not meet the test requirements, you MUST re-adjust 
 * the method.
 */

/* The HZ value could be found in the build header file */
/* 100 -> 10ms, 1000 -> 1ms , etc                       */
#define WFA_KERNEL_MIN_TIMER_RES   100   /* HZ Value for 10 ms */

void wfaTxSleepTime(int profile, int rate, int *sleepTime, int *throttledRate)
{
    *sleepTime=0;     /* in microseconds */
    /* calculate the sleep time based on frame rate */

    /*
     * Framerate is still required for Multicast traffic
     * Sleep and hold for a timeout.
     *
     * For WMM traffic, the framerate must also need for VO and VI.
     * the framerate 500, OS may not handle it precisely.
     */
    switch(profile)
    {
        /*
         * make it a fix rate
         */
        case PROF_MCAST:
#if 0
        if(rate > 100)
            *sleepTime = 100000;  /* sleep for 100 ms */
            *throttledRate = 40;
#endif
		if(rate < 500 && rate >= 50)
        {
            *sleepTime = 100000;  /* sleep for 100 ms */
            *throttledRate = WFA_MCAST_FRATE;
        }
        else
        {
            *sleepTime = 100000;
            *throttledRate = rate;
        }

        break;

        /*
         * Vendor must find ways to better adjust the speed for their own device
         */
        case PROF_IPTV:
        case PROF_FILE_TX:
        if(rate >=50 || rate == 0)
        {
	    /* 
	     * this sleepTime indeed is now being used for time period  
	     * to send packets in the throttled Rate.  
	     * The idea here is that in each fixed 20 minisecond period,
	     * The device will send rate/50 (rate = packets / second),
	     * then go sleep for rest of time.
	     */
            *sleepTime = 20000; /* fixed 20 miniseconds */
            *throttledRate = (rate?rate:2500)/50;
	    printf("Sleep time %i, throttledRate %i\n", *sleepTime, *throttledRate);
        }
        else if (rate > 0 && rate <= 50) /* typically for voice */
        {
            *throttledRate = 1;
            *sleepTime = 1000*1000/rate;
        }
        break;
        default:
          DPRINT_ERR(WFA_ERR, "Incorrect profile\n");
    } 
}

#define WFA_TIME_DIFF(before, after, rtime, dtime) \
             dtime = rtime + (after.tv_sec*1000000 + after.tv_usec) - (before.tv_sec*1000000 + before.tv_usec);

void buzz_time(int delay)
{
    struct timeval now, stop;
    int diff;
    int remain_time = 0;

    gettimeofday(&stop, 0);

    stop.tv_usec += delay;
    if(stop.tv_usec > 1000000)
    {
        stop.tv_usec -=1000000;
	stop.tv_sec +=1;
    }
	//gettimeofday(&then, 0);
		
    do
    {
        gettimeofday(&now, 0);
	WFA_TIME_DIFF(now, stop, remain_time, diff);
    } while(diff>0);
//gettimeofday(&now, 0);
	//	printf("burning delay is %d now sec %d, usec %d early sec %d usec %d\n",delay,now.tv_sec,now.tv_usec,then.tv_sec,then.tv_usec);

}

/**************************************************/
/* the actually functions to send/receive packets */
/**************************************************/

/* This is going to be a blocking SEND till it finishes */
int wfaSendLongFile(int mySockfd, int streamid, BYTE *aRespBuf, int *aRespLen)
{
    tgProfile_t           *theProf = NULL;
    tgStream_t            *myStream = NULL;
    struct sockaddr_in    toAddr;
    char                  *packBuf; 
    int  packLen;
    int  bytesSent;
    dutCmdResponse_t sendResp;
    int sleepTime = 0;
    int throttledRate = 0;
    struct timeval before, after,after1,af; 
    int difftime = 0,x;
    int counter = 0;
    struct timeval stime;
    int throttled_est_cost;
    int act_sleep_time;
   gettimeofday(&af,0);
   
    DPRINT_INFO(WFA_OUT, "Entering sendLongFile %i at sec %d usec %d\n", streamid,af.tv_sec,af.tv_usec);
    /* find the profile */
    myStream = findStreamProfile(streamid);
    if(myStream == NULL)
    {
        return FALSE;    
    }

    theProf = &myStream->profile;

    if(theProf == NULL)
    {
        return FALSE;
    }

    packLen = theProf->pksize;

    /* allocate a buf */
    packBuf = (char *)malloc(packLen);
    memset(packBuf, 1, packLen);

    /* fill in the header */
    strncpy(packBuf, "1345678", sizeof(tgHeader_t));

    /* initialize the destination address */
    memset(&toAddr, 0, sizeof(toAddr));
    toAddr.sin_family = AF_INET;
    toAddr.sin_addr.s_addr = inet_addr(theProf->dipaddr);
    toAddr.sin_port = htons(theProf->dport); 

    /* if a frame rate and duration are defined, then we know
     * interval for each packet and how many packets it needs to
     * send.
     */
    if(theProf->duration != 0)
    {
	
        printf("duration %i\n", theProf->duration);
        
        /* 
         *  use this to decide periodical interval sleep time and frames to send
         *  int the each interval.
         *  Each device should adopt a own algorithm for better performance
         */
        wfaTxSleepTime(theProf->profile, theProf->rate, &sleepTime, &throttledRate);
        /* 
         * alright, we need to raise the priority level of the process
         * to improve the real-time performance of packet sending.
         * Since this is for tuning purpose, it is optional implementation.
         */
        //wfaSetProcPriority(60);
	
	//interval = 1*1000000/theProf->rate ; // in usec;

	// Here assumes it takes 20 usec to send a packet
	throttled_est_cost = throttledRate * 20;  // MUST estimate the cost per ppk
	act_sleep_time = sleepTime - adj_latency;
	if (act_sleep_time <= 0)
	    act_sleep_time = sleepTime;  

        printf("sleep time %i act_sleep_time %i\n", sleepTime, act_sleep_time);

        runLoop=1;
		       
        while(runLoop)
        {
			
#ifdef _WINDOWS_OLD
			MSG msg = { 0, 0, 0, 0 };
			if(PeekMessage(&msg,NULL,0,0,PM_REMOVE))
			{
				if(msg.message == WM_TIMER)
				{
					TranslateMessage (&msg);
					DispatchMessage(&msg);
				}
				printf( "\r\n Timer DONE for packlen %d\n",packLen);
				msg.message = 0;
			}
#endif
			if(packLen == 1001)
			  x=1;
	   counter++;
           /* fill in the counter */
           int2BuffBigEndian(counter, &((tgHeader_t *)packBuf)->hdr[8]);

           /*
            * the following code is only used to slow down
            * over fast traffic flooding the buffer and cause
            * packet drop or the other end not able to receive due to
            * some limitations, purely for experiment purpose.
            * each implementation needs some fine tune to it.
            */
	   if(counter ==1)
	   {
               gettimeofday(&before, NULL);

               before.tv_usec += sleepTime;
               if(before.tv_usec > 1000000)
               {
                   before.tv_usec -= 1000000;
                   before.tv_sec +=1;
               }
           }

           if(throttledRate != 0)
           {
              if(counter%throttledRate == 0)
              {
                 gettimeofday(&after, NULL);
	             difftime = wfa_itime_diff(&after, &before);

                 if(difftime > adj_latency)
                 {
#ifdef _WINDOWS
                    // too much time left, go sleep
					//printf("\r\n Sleeping for %d time", (difftime-adj_latency)/1000);
					Sleep((difftime-adj_latency)/10000);
#else
					usleep((difftime-adj_latency);
#endif
                    gettimeofday(&after1, NULL);
	                difftime = wfa_itime_diff(&after1, &before);
                 }
				 //printf("before sec %d, usec %d sleep %d intermed sec %d usec %d  latency %d  after sec %d usec %d\n",before.tv_sec,before.tv_usec,sleepTime,after.tv_sec,after.tv_usec,adj_latency,after1.tv_sec,after1.tv_usec);

		 // burn the rest to absort latency
	             if(difftime >0)
	                 buzz_time(difftime);

	             before.tv_usec += sleepTime;
	             if(before.tv_usec > 1000000)
	             {
	                 before.tv_usec -= 1000000;
		             before.tv_sec +=1;
	             }
             }
           } // otherwise, it floods 

	   /*
	    * Fill the timestamp to the header.
	    */
	   gettimeofday(&stime, NULL);

	   int2BuffBigEndian(stime.tv_sec, &((tgHeader_t *)packBuf)->hdr[12]);
	   int2BuffBigEndian(stime.tv_usec, &((tgHeader_t *)packBuf)->hdr[16]);
       //Sleep(1);
	   
           bytesSent = wfaTrafficSendTo(mySockfd, packBuf, packLen, 
                            (struct sockaddr *)&toAddr);
		   //if(packLen == 1001)
			//printf("\r\n sent %d\n",bytesSent);
           if(bytesSent != -1)
           {
              myStream->stats.txPayloadBytes += bytesSent; 
              myStream->stats.txFrames++ ;
           }
           else
           {
#ifdef _WINDOWS
               int errsv = WSAGetLastError();
               switch(errsv)
               {
	           

                   case WSAENOBUFS:
                        DPRINT_ERR(WFA_ERR, "send error\n");
                        Sleep(20);             /* hold for 1 ms */
                        counter-- ;
                        myStream->stats.txFrames--;
                   break;

                   case WSAECONNRESET:
					   DPRINT_ERR(WFA_ERR, "send error RESET\n");
                        runLoop = 0;
                   break;
                   case WSAENOTCONN:
					   DPRINT_ERR(WFA_ERR, "send error not connected\n");
                        runLoop = 0;
                   break;
				   case WSANOTINITIALISED:
					   DPRINT_ERR(WFA_ERR, "WSAStartup not yet called\n");
					   break;
                   default:
                       DPRINT_ERR(WFA_ERR, "Packet sent error %d\n",errsv);
					   Sleep(20);
				  
               }
#else
int errsv = errno;
               switch(errsv)
               {
	           case EAGAIN:
                   case ENOBUFS:
                        DPRINT_ERR(WFA_ERR, "send error\n");
                        usleep(1000);             /* hold for 1 ms */
                        counter-- ;
                        myStream->stats.txFrames--;
                   break;
                   case ECONNRESET:
                        runLoop = 0;
                   break;
                   case EPIPE:
                        runLoop = 0;
                   break;
                   default:
                      perror("sendto: ");
                      DPRINT_ERR(WFA_ERR, "Packet sent error\n");
               }
#endif

           }

        }


        /*
         * lower back to an original level if the process is raised previously
         * It is optional.
         */
        //wfaSetProcPriority(30); 
    }
    else /* invalid parameters */
    {
        /* encode a TLV for response for "invalid ..." */
        sendResp.status = STATUS_INVALID;
        wfaEncodeTLV(WFA_TRAFFIC_AGENT_SEND_RESP_TLV, 4, 
                 (BYTE *)&sendResp, (BYTE *)aRespBuf);

        /* done here */
        *aRespLen = WFA_TLV_HDR_LEN + 4; 

		free(packBuf);

        return DONE;
    }

    gtgSend = 0;

    /* free the buffer */
    free(packBuf);

    //printf("done sending long\n");
    /* return statistics */
    sendResp.status = STATUS_COMPLETE;
    sendResp.streamId = myStream->id;
	printf("\r\n Sent frames are %d\n",myStream->stats.txFrames);
    memcpy(&sendResp.cmdru.stats, &myStream->stats, sizeof(tgStats_t)); 

    wfaEncodeTLV(WFA_TRAFFIC_AGENT_SEND_RESP_TLV, sizeof(dutCmdResponse_t), 
                 (BYTE *)&sendResp, (BYTE *)aRespBuf);

    *aRespLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

    //system("iwpriv ath2 sleep 0"); // make it always sleep
   
   
    return DONE;
}

/* this only sends one packet a time */
int wfaSendShortFile(int mySockfd, int streamid, BYTE *sendBuf, int pksize, BYTE *aRespBuf, int *aRespLen)
{
   BYTE *packBuf = sendBuf; 
   struct sockaddr_in toAddr;
   tgProfile_t *theProf;
   tgStream_t *myStream;
   int packLen, bytesSent=-1;
   dutCmdResponse_t sendResp;

   if(mySockfd == -1)
   {
      /* stop */ 
      gtgTransac = 0;
      gtimeOut = 0; 
      gtgRecv = 0;
      gtgSend = 0;
      printf("stop short traffic\n");

      myStream = findStreamProfile(streamid);
      if(myStream != NULL)
      {
          sendResp.status = STATUS_COMPLETE;
          sendResp.streamId = streamid;
          memcpy(&sendResp.cmdru.stats, &myStream->stats, sizeof(tgStats_t)); 
    
          wfaEncodeTLV(WFA_TRAFFIC_AGENT_SEND_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)&sendResp, aRespBuf);

          *aRespLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
      }

      return DONE;
   }

   /* find the profile */
   myStream = findStreamProfile(streamid);

   theProf = &myStream->profile;
   if(theProf == NULL)
   {
        return FALSE;
   }

   if(pksize == 0)
      packLen = theProf->pksize;
   else
      packLen = pksize;

   memset(&toAddr, 0, sizeof(toAddr));
   toAddr.sin_family = AF_INET;
   toAddr.sin_addr.s_addr = inet_addr(theProf->sipaddr);
   toAddr.sin_port = htons(theProf->sport); 

   if(gtgRecv && gtgTransac)
   {
      toAddr.sin_addr.s_addr = inet_addr(theProf->sipaddr);
      toAddr.sin_port = htons(theProf->sport); 
   }
   else if(gtgSend && gtgTransac)
   {
      toAddr.sin_addr.s_addr = inet_addr(theProf->dipaddr);
      toAddr.sin_port = htons(theProf->dport); 
   }

   int2BuffBigEndian(myStream->stats.txFrames, &((tgHeader_t *)packBuf)->hdr[8]);

   if(mySockfd != -1)
      bytesSent = wfaTrafficSendTo(mySockfd, (char *)packBuf, packLen, (struct sockaddr *)&toAddr);


   if(bytesSent != -1)
   {
      myStream->stats.txFrames++;
      myStream->stats.txPayloadBytes += bytesSent;
   }
   else
   {
#ifdef _WINDOWS
      int errsv = WSAGetLastError();
	  switch(errsv)
      {
	      case WSAENOBUFS:
          DPRINT_ERR(WFA_ERR, "send error\n");
          Sleep(1);             /* hold for 1 ms */
          myStream->stats.txFrames--;
          break;

          case WSAECONNRESET:
          runLoop = 0;
          break;

          case WSAENOTCONN:
          runLoop = 0;
          break;

          case WSANOTINITIALISED:
		  DPRINT_ERR(WFA_ERR, "WSAStartup not yet called\n");
          break;

          default:
          DPRINT_ERR(WFA_ERR, "Packet sent error\n");
				  
      }
#else
int errsv = errno;
      switch(errsv)
      {
          case EAGAIN:
          case ENOBUFS:
             DPRINT_ERR(WFA_ERR, "send error\n");
             usleep(1000);             /* hold for 1 ms */
             myStream->stats.txFrames--;
	  break;
	  default:
             perror("sendto: ");
      }
#endif

      
   }

   sentTranPkts++;

   return TRUE;
}

/* always receive from a specified IP address and Port */
int wfaRecvFile(int mySockfd, int streamid, char *recvBuf)
{
    /* how many packets are received */  
    char *packBuf = recvBuf; 
    struct sockaddr_in fromAddr;
    tgProfile_t *theProf;
    tgStream_t *myStream;
    unsigned int bytesRecvd;
//    int ioflags;
    int lostPkts;
#ifdef _WINDOWS
	u_long NonBlock=0; // make it block
#endif
    /* find the profile */
    myStream = findStreamProfile(streamid);

    theProf = &myStream->profile;
    if(theProf == NULL)
    {
        return FALSE;
    }

    memset(packBuf, 0, MAX_UDP_LEN);

    memset(&fromAddr, 0, sizeof(fromAddr));
    fromAddr.sin_family = AF_INET;
    fromAddr.sin_addr.s_addr = inet_addr(theProf->dipaddr);
    fromAddr.sin_port = htons(theProf->dport); 

    if(gtgRecv && gtgTransac)
    {
       fromAddr.sin_addr.s_addr = inet_addr(theProf->sipaddr);
       fromAddr.sin_port = htons(theProf->sport); 
    }
    else if(gtgSend && gtgTransac)
    {
       fromAddr.sin_addr.s_addr = inet_addr(theProf->dipaddr);
       fromAddr.sin_port = htons(theProf->dport); 
    }
#ifndef _WINDOWS
	/* get current flags setting */
    ioflags = fcntl(mySockfd, F_GETFL, 0);

    /* set only BLOCKING flag to non-blocking */
    fcntl(mySockfd, F_SETFL, ioflags | O_NONBLOCK); 
#else
	if (ioctlsocket(mySockfd, FIONBIO, &NonBlock) == SOCKET_ERROR)
     {
//          printf("ioctlsocket() failed \n");
          return -1;
     }
#endif
    /* it is always to receive at least one packet, in case more in the
       queue, just pick them up.
     */
    bytesRecvd = wfaTrafficRecv(mySockfd, packBuf, (struct sockaddr *)&fromAddr);

	if(!gtgTransac)
	{
         while(bytesRecvd != -1)
         {
#ifdef WFA_WMM_EXT
			 struct timeval currtime;
			 int le2eCnt = myStream->stats.rxFrames;
			 tgE2EStats_t *e2esp = myStream->e2ebuf;

			 int totalE2Cnt = 6000;
#endif
             myStream->stats.rxFrames++;    
             myStream->stats.rxPayloadBytes +=bytesRecvd;

             /*
              *  Get the lost packet count
              */
             lostPkts =bigEndianBuff2Int(&((tgHeader_t *)packBuf)->hdr[8]) - 1 - myStream->lastPktSN; 
             myStream->stats.lostPkts += lostPkts; 
             myStream->lastPktSN = bigEndianBuff2Int(&((tgHeader_t *)packBuf)->hdr[8]); 

#ifdef WFA_WMM_EXT
			 if(theProf->profile == PROF_IPTV)
             {
                 struct timeval ttval, currTimeVal;

                 int sn = bigEndianBuff2Int(&((tgHeader_t *)recvBuf)->hdr[8]);
                 ttval.tv_sec = bigEndianBuff2Int(&((tgHeader_t *)recvBuf)->hdr[12]);
                 ttval.tv_usec = bigEndianBuff2Int(&((tgHeader_t *)recvBuf)->hdr[16]);
                 gettimeofday(&currTimeVal, NULL);

				 /*
                  * take the end2end stats, limit to the max voice pkt number
                  */
			     printf("receive the %i packet\n", le2eCnt);

                 if(le2eCnt < totalE2Cnt)
                 {
                    tgE2EStats_t *ep = e2esp + le2eCnt;
                    ep->seqnum = sn;
                    ep->rsec = ttval.tv_sec;
                    ep->rusec = ttval.tv_usec;

                    ep->lsec = currTimeVal.tv_sec;
                    ep->lusec = currTimeVal.tv_usec;

                    if(ep->lusec  < 0)
                    {
                       ep->lsec -=1;
                       ep->lusec += 1000000;
                    }
                    else if(ep->lusec >= 1000000)
                    {
                       ep->lsec += 1;
                       ep->lusec -= 1000000;
                    }
                }
             }
#endif
	         bytesRecvd = wfaTrafficRecv(mySockfd, packBuf, (struct sockaddr *)&fromAddr);
         }  
	} 

    if(bytesRecvd != -1)
    {
         myStream->stats.rxFrames++;    
         myStream->stats.rxPayloadBytes +=bytesRecvd;

             /*
              *  Get the lost packet count
              */
         lostPkts =bigEndianBuff2Int(&((tgHeader_t *)packBuf)->hdr[8]) - 1 - myStream->lastPktSN; 
         myStream->stats.lostPkts += lostPkts; 
         myStream->lastPktSN = bigEndianBuff2Int(&((tgHeader_t *)packBuf)->hdr[8]); 
    }

    return (bytesRecvd);
}

void  wfaRecvStatsResp(int sock, BYTE *buf)
{
   int i, total=0, pkLen;
   tgStream_t *allStreams = gStreams;
   dutCmdResponse_t *recvStatsResp = (dutCmdResponse_t *)buf, *first;
   char buff[WFA_BUFF_1K];
   printf("wfaRecvStatsResp: gstream is %d\n",gStreams);
   if(recvStatsResp == NULL)
      return;

   first = recvStatsResp;
 
   for(i = 0; i < WFA_MAX_TRAFFIC_STREAMS; i++)
   {
      if((allStreams->id != 0) && (allStreams->profile.direction == DIRECT_RECV) && (allStreams->state == WFA_STREAM_ACTIVE))
      {
          recvStatsResp->status = STATUS_COMPLETE;
          recvStatsResp->streamId = allStreams->id;
          memcpy(&recvStatsResp->cmdru.stats, &allStreams->stats, sizeof(tgStats_t));          

          recvStatsResp++;
          total++;
      } 
      allStreams++;
   } 

#if 0
   printf("%i %i %i %i %i %i\n", first->cmdru.stats.txFrames,
                                  first->cmdru.stats.rxFrames,
                                  first->cmdru.stats.txPayloadBytes,
                                  first->cmdru.stats.rxPayloadBytes); 
#endif

   wfaEncodeTLV(WFA_TRAFFIC_AGENT_RECV_STOP_RESP_TLV, total*sizeof(dutCmdResponse_t),
                 (BYTE *)first, (BYTE *)buff);

   pkLen = WFA_TLV_HDR_LEN + total*sizeof(dutCmdResponse_t); 

#if 0
   for(i = 0; i< pkLen; i++)
   printf("%x ", buff[i]);

   printf("\n");
#endif

   if(wfaCtrlSend(sock, (BYTE *)buff, pkLen) != pkLen)
   {
       DPRINT_WARNING(WFA_WNG, "wfaCtrlSend Error\n");
   }

   printf("wfaRecvStatsResp exit: gstream is %d\n",gStreams);
   return;
}
